<html>
<head>
<style>
table, th, tr, td {
  border: 1px solid;
  font-family: monospace;
}
th {
  font-weight: bold;
}
</style>
</head>
<body>
<h1>How many incomplete cubes are there?</h1>
<p style="text-indent:40px;">This investigation was inspired by a <a href="https://www.youtube.com/watch?v=_BrFKp-U8GI">3Blue1Brown guest video</a> written by Paul Dancstep.</p>
<p style="text-indent:40px;">The question presented in the video is, how many distinct subsets of the set of edges of a cube are there, or how many colorings of the edges of a cube are there, given the following constraints:</p>
<p style="text-indent:80px;"><tt>1) The colored edges must be connected.</tt></p>
<p style="text-indent:80px;"><tt>2) Rotationally equivalent colorings are excluded.</tt></p>
<p style="text-indent:80px;"><tt>3) Colorings that fit within a plane or on one side of the cube are excluded.</tt></p>
<p style="text-indent:80px;"><tt>4) The empty coloring and complete coloring are excluded.</tt></p>
<p style="text-indent:40px;">These guidelines will be modified slightly here. Instead of looking only at connected cubes, we will look at cubes with various numbers of connected colored components, and will not worry much about points 3 and 4. </p>
<p style="text-indent:40px;">First there will be an automated enumeration of all the cubes, and then a theoretical discussion.</p>
<p style="text-indent:40px;">In total there are:</p>
<p style="text-indent:80px;"><tt>1 cube with 0 components</tt></p>
<p style="text-indent:80px;"><tt>127 cubes with 1 component</tt></p>
<p style="text-indent:80px;"><tt>72 cubes with 2 components</tt></p>
<p style="text-indent:80px;"><tt>16 cubes with 3 components</tt></p>
<p style="text-indent:80px;"><tt>2 cubes with 4 components</tt></p>
<p style="text-indent:80px;"><tt>218 cubes overall</tt></p>
<h1 id="svgh0">Rotationally distinct cubes with 0 edges</h1>
<svg id="svg0" height="0" width="0" xmlns="http://www.w3.org/2000/svg">
<h1 id="svgh1">Rotationally distinct cubes with 1 edge</h1>
<svg id="svg1" height="0" width="0" xmlns="http://www.w3.org/2000/svg">
<h1 id="svgh2">Rotationally distinct cubes with 2 edges</h1>
<svg id="svg2" height="0" width="0" xmlns="http://www.w3.org/2000/svg">
<h1 id="svgh3">Rotationally distinct cubes with 3 edges</h1>
<svg id="svg3" height="0" width="0" xmlns="http://www.w3.org/2000/svg">
<h1 id="svgh4">Rotationally distinct cubes with 4 edges</h1>
<svg id="svg4" height="0" width="0" xmlns="http://www.w3.org/2000/svg">
<h1 id="svgh5">Rotationally distinct cubes with 5 edges</h1>
<svg id="svg5" height="0" width="0" xmlns="http://www.w3.org/2000/svg">
<h1 id="svgh6">Rotationally distinct cubes with 6 edges</h1>
<svg id="svg6" height="0" width="0" xmlns="http://www.w3.org/2000/svg">
<h1 id="svgh7">Rotationally distinct cubes with 7 edges</h1>
<svg id="svg7" height="0" width="0" xmlns="http://www.w3.org/2000/svg">
<h1 id="svgh8">Rotationally distinct cubes with 8 edges</h1>
<svg id="svg8" height="0" width="0" xmlns="http://www.w3.org/2000/svg">
<h1 id="svgh9">Rotationally distinct cubes with 9 edges</h1>
<svg id="svg9" height="0" width="0" xmlns="http://www.w3.org/2000/svg">
<h1 id="svgh10">Rotationally distinct cubes with 10 edges</h1>
<svg id="svg10" height="0" width="0" xmlns="http://www.w3.org/2000/svg">
<h1 id="svgh11">Rotationally distinct cubes with 11 edges</h1>
<svg id="svg11" height="0" width="0" xmlns="http://www.w3.org/2000/svg">
<h1 id="svgh12">Rotationally distinct cubes with 12 edges</h1>
<svg id="svg12" height="0" width="0" xmlns="http://www.w3.org/2000/svg">
</svg>
<h1>How could this be calculated without a computer? (in progress)</h1>
<p style="text-indent:40px;">There is a detailed discussion in the video linked above of how to use group theory to calculate the number of rotationally distinct cubes.</p>
<p style="text-indent:40px;">However, this does not take into account the number of connected components.</p>
<p style="text-indent:40px;">Below both will be explained in more detail.</p>
<h1>Rotational groups (in progress)</h1>
<p style="text-indent:40px;">If a coloring of a cube has no symmetries, then there are 24 different rotated versions of that cube. </p>
<!-- TODO: insert some diagrams here -->
<p style="text-indent:40px;">If the cube does have symmetries, then the number of distinct rotated versions of the cube is a divisor of 24. </p>
<p style="text-indent:40px;">It turns out that the number of rotationally distinct cubes can be calculated by starting with the number of colorings of the cube, adding in the number of symmetric colorings to make up for undercounting, and then dividing by 24 to account for rotations. </p>
<!-- TODO: give the example of a square -->
<h1>Cube Rotation Group Representation (in progress)</h1>
<p style="text-indent:40px;">The group of rotations of a cube can be represented compactly as a set of 24 rotation matrices, which is how the automated enumeration of the cubes was implemented.</p>
<p style="text-indent:40px;">If the corners of each cube are aligned to the points (+/-1,+/-1,+/-1), then the matrices representing the rotational symmetries of the cube all have terms that are 1, 0, and -1. </p>
<p style="text-indent:40px;">This group is also the group of <a href="https://en.wikipedia.org/wiki/Octahedral_symmetry">rotational symmetries of the octahedron</a>. </p>
<!-- TODO: generate two-dimensional array of cube diagrams showing a square with an attached edge rotating around to each face of the cube, and align the rotational matrices with that array -->
<!-- TODO: generate a grouping of cube diagrams showing n-fold rotation around each face/edge/corner, and align the rotational matrices with that array -->
<table id="configsTable" style="width:600px;margin-left:80px;text-align:center;">
	<tr>
		<th>
			[ 1, 0, 0]<br/>
			[ 0, 1, 0]<br/>
			[ 0, 0, 1]
		</th>
		<th>
			[ 1, 0, 0]<br/>
			[ 0, 0,-1]<br/>
			[ 0, 1, 0]
		</th>
		<th>
			[ 1, 0, 0]<br/>
			[ 0,-1, 0]<br/>
			[ 0, 0,-1]
		</th>
		<th>
			[ 1, 0, 0]<br/>
			[ 0, 0, 1]<br/>
			[ 0,-1, 0]
		</th>
		<th>
			[ 0, 0,-1]<br/>
			[ 0, 1, 0]<br/>
			[ 1, 0, 0]
		</th>
		<th>
			[-1, 0, 0]<br/>
			[ 0, 1, 0]<br/>
			[ 0, 0,-1]
		</th>
	</tr>
	<tr>
		<th>
			[ 0, 0, 1]<br/>
			[ 0, 1, 0]<br/>
			[-1, 0, 0]
		</th>
		<th>
			[ 0,-1, 0]<br/>
			[ 1, 0, 0]<br/>
			[ 0, 0, 1]
		</th>
		<th>
			[-1, 0, 0]<br/>
			[ 0,-1, 0]<br/>
			[ 0, 0, 1]
		</th>
		<th>
			[ 0, 1, 0]<br/>
			[-1, 0, 0]<br/>
			[ 0, 0, 1]
		</th>
		<th>
			[-1, 0, 0]<br/>
			[ 0, 0, 1]<br/>
			[ 0, 1, 0]
		</th>
		<th>
			[-1, 0, 0]<br/>
			[ 0, 0,-1]<br/>
			[ 0,-1, 0]
		</th>
	</tr>
	<tr>
		<th>
			[ 0, 0, 1]<br/>
			[ 0,-1, 0]<br/>
			[ 1, 0, 0]
		</th>
		<th>
			[ 0, 0,-1]<br/>
			[ 0,-1, 0]<br/>
			[-1, 0, 0]
		</th>
		<th>
			[ 0, 1, 0]<br/>
			[ 1, 0, 0]<br/>
			[ 0, 0,-1]
		</th>
		<th>
			[ 0,-1, 0]<br/>
			[-1, 0, 0]<br/>
			[ 0, 0,-1]
		</th>
		<th>
			[ 0, 0, 1]<br/>
			[ 1, 0, 0]<br/>
			[ 0, 1, 0]
		</th>
		<th>
			[ 0, 1, 0]<br/>
			[ 0, 0, 1]<br/>
			[ 1, 0, 0]
		</th>
	</tr>
	<tr>
		<th>
			[ 0, 0,-1]<br/>
			[-1, 0, 0]<br/>
			[ 0, 1, 0]
		</th>
		<th>
			[ 0,-1, 0]<br/>
			[ 0, 0, 1]<br/>
			[-1, 0, 0]
		</th>
		<th>
			[ 0, 0, 1]<br/>
			[-1, 0, 0]<br/>
			[ 0,-1, 0]
		</th>
		<th>
			[ 0,-1, 0]<br/>
			[ 0, 0,-1]<br/>
			[ 1, 0, 0]
		</th>
		<th>
			[ 0, 0,-1]<br/>
			[ 1, 0, 0]<br/>
			[ 0,-1, 0]
		</th>
		<th>
			[ 0, 1, 0]<br/>
			[ 0, 0,-1]<br/>
			[-1, 0, 0]
		</th>
	</tr>
</table>
<p style="text-indent:40px;">So for instance, to rotate around one corner of the cube, we could multiply that rotation matrix by the list of column vectors representing the corners of the cube:</p>

<table id="configsTable" style="width:500px;margin-left:80px;text-align:center;">
	<tr>
		<th>
			[ 0, 0,-1] [ 1, 1, 1, 1,-1,-1,-1,-1] [-1, 1,-1, 1,-1, 1,-1, 1]<br/>
			[ 1, 0, 0]*[ 1, 1,-1,-1, 1, 1,-1,-1]=[ 1, 1, 1, 1,-1,-1,-1,-1]<br/>
			[ 0,-1, 0] [ 1,-1, 1,-1, 1,-1, 1,-1] [-1,-1, 1, 1,-1,-1, 1, 1]
		</th>
	</tr>
</table>
<!-- TODO: list of rotation matrices along with interactive tool to apply them to a cube -->
<p style="text-indent:40px;"></p>
<h1>Connected colorings (in progress)</h1>
<p style="text-indent:40px;">In general, it is to be expected that finding the number of connected colorings of a graph (a collection of nodes connected by edges) will be computationally expensive, approaching the cost of simply checking every possible coloring. </p>
<p style="text-indent:40px;">The <a href="https://cstheory.stackexchange.com/questions/3465/complexity-of-counting-all-connected-subgraphs">connected subgraph counting problem</a> is in <a href="https://en.wikipedia.org/wiki/%E2%99%AFP">the complexity class #P</a> which is related to and harder than <a href="https://en.wikipedia.org/wiki/NP_(complexity)">the complexity class NP</a>.</p>
<p style="text-indent:40px;">The square edge graph has properties that make it much more efficient to work with. It is small, symmetric, and sparse. The following analysis will rely on these special properties.</p>
<p style="text-indent:40px;">We can begin by splitting the cube up into three sections, the bottom face, top face, and connecting vertical bridges, and splitting up the analysis by how many of these bridge edges are colored.</p>
<p style="text-indent:40px;">There will be no consideration of rotational equivalence in this section, so two colorings of the cube that are rotationally equivalent will be considered distinct for the purpose of counting. However, rotational symmetry will be used extensively to speed up the counting process.</p>
<h2>Cube with 0 bridges</h2>
<p style="text-indent:40px;">Suppose that none of the bridges are colored in. In that case, the top and bottom faces are independent of each other and cannot be connected. </p>
<p style="text-indent:40px;">The edges of a square can be colored 1 way with no edges, 2 ways with 2 disconnected edges, and 13 ways with connected edges.</p>
<svg id="svg_square" height="0" width="0" xmlns="http://www.w3.org/2000/svg">
<p style="text-indent:40px;">We can combine these numbers by adding the number of connected components, and multiplying the number of independent colorings on the top and bottom faces.</p>
<table id="configsTable" style="width:600px;margin-left:80px;text-align:center;">
	<tr><th>        </th><th>0 CC:  1</th><th>1 CC:  13</th><th>2 CC:  2</th></tr>
	<tr><th>0 CC:  1</th><td>0 CC:  1</td><td>1 CC:  13</td><td>2 CC:  2</td></tr>
	<tr><th>1 CC: 13</th><td>1 CC: 13</td><td>2 CC: 169</td><td>3 CC: 26</td></tr>
	<tr><th>2 CC:  2</th><td>2 CC:  2</td><td>3 CC:  26</td><td>4 CC:  4</td></tr>
</table>
<p style="text-indent:40px;">For the whole cube with no bridges there are this many colorings of each type:</p>
<p style="text-indent:80px;"><tt>0 CC: 1</tt></p>
<p style="text-indent:80px;"><tt>1 CC: 26</tt></p>
<p style="text-indent:80px;"><tt>2 CC: 173</tt></p>
<p style="text-indent:80px;"><tt>3 CC: 52</tt></p>
<p style="text-indent:80px;"><tt>4 CC: 4</tt></p>
<h2>Cube with 1 bridge</h2>
<p style="text-indent:40px;">Suppose that one of the bridges is colored in. There are four ways to do this, and the number of colorings in each case will be the same, so we can multiply any number we get in this section by 4 at the end. </p>
<p style="text-indent:40px;">Because there is one edge that is already colored, there will be at least one connected component, and whether or not there is more than one will depend on whether other edges are connected to this one.</p>
<p style="text-indent:40px;">Because three of the bridges are not colored in, the top and bottom faces are almost independent of one another.</p>
<p style="text-indent:40px;">The independent cases to be distinguished are how many connected components there are on a face that do not touch the bridge.</p>
<svg id="svg_1_bridge" height="0" width="0" xmlns="http://www.w3.org/2000/svg">
<p style="text-indent:40px;">We can combine these numbers by adding the number of connected components, minus one for the duplicated bridge component, and multiplying the number of independent colorings on the top and bottom faces.</p>
<table id="configsTable" style="width:600px;margin-left:80px;text-align:center;">
	<tr><th>        </th><th>1 CC: 11</th><th>2 CC:  5</th></tr>
	<tr><th>1 CC: 11</th><td>1 CC:121</td><td>2 CC: 55</td></tr>
	<tr><th>2 CC:  5</th><td>2 CC: 55</td><td>3 CC: 25</td></tr>
</table>
<p style="text-indent:40px;">For the whole cube with one colored bridge there are this many colorings of each type:</p>
<p style="text-indent:80px;"><tt>1 CC: 121</tt></p>
<p style="text-indent:80px;"><tt>2 CC: 110</tt></p>
<p style="text-indent:80px;"><tt>3 CC: 25</tt></p>
<h2>Cube with 2 adjacent bridges</h2>
<p style="text-indent:40px;">Suppose that two of the bridges are colored in, and they are on the same side. There are four ways to do this, and the number of colorings in each case will be the same, so we can multiply any number we get in this section by 4 at the end. </p>
<p style="text-indent:40px;">Because there are two edges already colored in, there will be at least one connected component, and whether there are two or more will depend on how these are connected.</p>
<p style="text-indent:40px;">The independent cases to be distinguished on each face are whether these two bridges get connected, and whether there are any other components totally disconnected from the bridges.</p>
<svg id="svg_2_adj_bridge" height="0" width="0" xmlns="http://www.w3.org/2000/svg">
<p style="text-indent:40px;">We can combine these numbers by adding the number of connected components, minus one if the bridges are connected on both faces or two if they are not, and multiplying the number of independent colorings on the top and bottom faces.</p>
<table id="configsTable" style="width:600px;margin-left:80px;text-align:center;">
	<tr><th>          </th><th>BD 2 CC:  6</th><th>BD 3 CC: 1</th><th>BC 1 CC:  8</th><th>BC 2 CC: 1</th></tr>
	<tr><th>BD 2 CC: 6</th><td>   2 CC: 36</td><td>   3 CC: 6</td><td>   1 CC: 48</td><td>   2 CC: 6</td></tr>
	<tr><th>BD 3 CC: 1</th><td>   3 CC:  6</td><td>   4 CC: 1</td><td>   2 CC:  8</td><td>   3 CC: 1</td></tr>
	<tr><th>BC 1 CC: 8</th><td>   1 CC: 48</td><td>   2 CC: 8</td><td>   1 CC: 64</td><td>   2 CC: 8</td></tr>
	<tr><th>BC 2 CC: 1</th><td>   2 CC:  6</td><td>   3 CC: 1</td><td>   2 CC:  8</td><td>   3 CC: 1</td></tr>
</table>
<p style="text-indent:40px;">For the whole cube with two adjacent colored bridges there are this many colorings of each type:</p>
<p style="text-indent:80px;"><tt>1 CC: 160</tt></p>
<p style="text-indent:80px;"><tt>2 CC: 80</tt></p>
<p style="text-indent:80px;"><tt>3 CC: 15</tt></p>
<p style="text-indent:80px;"><tt>4 CC: 1</tt></p>
<h2>Cube with 2 antipodal bridges</h2>
<p style="text-indent:40px;">Suppose that two of the bridges are colored in, and they are on opposite ends of the cube. There are two ways to do this, and the number of colorings in each case will be the same, so we can multiply any number we get in this section by 2 at the end. </p>
<p style="text-indent:40px;">In this case, every edge on the top and bottom faces touches one of the already colored bridges, so there cannot be more than 2 connected components.</p>
<p style="text-indent:40px;">Whether there are 2 or 1 connected components is determined by whether these two bridges are connected in any way at all. </p>
<svg id="svg_2_anti_bridge" height="0" width="0" xmlns="http://www.w3.org/2000/svg">
<p style="text-indent:40px;">We can combine these numbers by taking the lesser of the number of connected components, and multiplying the number of independent colorings on the top and bottom faces.</p>
<table id="configsTable" style="width:600px;margin-left:80px;text-align:center;">
	<tr><th>       </th><th>1 CC:  7</th><th>2 CC:  9</th></tr>
	<tr><th>1 CC: 7</th><td>1 CC: 49</td><td>1 CC: 63</td></tr>
	<tr><th>2 CC: 9</th><td>1 CC: 63</td><td>2 CC: 81</td></tr>
</table>
<p style="text-indent:40px;">For the whole cube with two antipodal colored bridges there are this many colorings of each type:</p>
<p style="text-indent:80px;"><tt>1 CC: 175</tt></p>
<p style="text-indent:80px;"><tt>2 CC: 81</tt></p>
<h2>Cube with 3 bridges</h2>
<p style="text-indent:40px;">Suppose that three of the bridges are colored in. There are four ways to do this, and the number of colorings in each case will be the same, so we can multiply any number we get in this section by 4 at the end. </p>
<p style="text-indent:40px;">In this case, every edge on the top and bottom faces touches one of the already colored bridges, so there cannot be more than 3 connected components.</p>
<p style="text-indent:40px;">Whether there are 3, 2, or 1 connected components is determined by whether these three briges are connected to each other, either directly or indirectly. </p>
<p style="text-indent:40px;">The interesting cases are whether all bridges are connected, or all disconnected, or which pair of bridges is connected. </p>
<svg id="svg_3_bridge" height="0" width="0" xmlns="http://www.w3.org/2000/svg">
<p style="text-indent:40px;">The number of connected components is a bit more complicated to calculate this time. If two bridges are connected on either face, then they are connected in the full cube, and if two different pairs of bridges are connected, then they are all connected. </p>
<table id="configsTable" style="width:600px;margin-left:80px;text-align:center;">
	<tr><th>         </th><th>1 CC:  6</th><th>2 CC T:  3</th><th>2 CC R:  3</th><th>2 CC D: 1</th><th>3 CC  :  3</th></tr>
	<tr><th>1 CC  : 6</th><td>1 CC: 36</td><td>1 CC  : 18</td><td>1 CC  : 18</td><td>1 CC  : 6</td><td>1 CC  : 18</td></tr>
	<tr><th>2 CC T: 3</th><td>1 CC: 18</td><td>2 CC T:  9</td><td>1 CC  :  9</td><td>1 CC  : 3</td><td>2 CC T:  9</td></tr>
	<tr><th>2 CC R: 3</th><td>1 CC: 18</td><td>1 CC  :  9</td><td>2 CC R:  9</td><td>1 CC  : 3</td><td>2 CC R:  9</td></tr>
	<tr><th>2 CC D: 1</th><td>1 CC:  6</td><td>1 CC  :  3</td><td>1 CC  :  3</td><td>2 CC D: 1</td><td>2 CC D:  3</td></tr>
	<tr><th>3 CC  : 3</th><td>1 CC: 18</td><td>2 CC T:  9</td><td>2 CC R:  9</td><td>2 CC D: 3</td><td>3 CC  :  9</td></tr>
</table>
<p style="text-indent:40px;">For the whole cube with three colored bridges there are this many colorings of each type:</p>
<p style="text-indent:80px;"><tt>1 CC: 186</tt></p>
<p style="text-indent:80px;"><tt>2 CC: 61</tt></p>
<p style="text-indent:80px;"><tt>3 CC: 9</tt></p>
<h2>Cube with 4 bridges</h2>
<p style="text-indent:40px;">Suppose that all four of the bridges are colored in. Every edge on the top and bottom faces touches two of the already colored bridges, so there cannot be more than 4 connected components and will usually be less.</p>
<p style="text-indent:40px;">There are three ways for any two adjacent bridges to be connected by an edge - on the top face, on the bottom face, or on both faces. In the remaining case there is no connecting edge on either face and the bridges are not connected.</p>
<p style="text-indent:40px;">If we imagine the entire cube flattened to a single square face, such that the colored edges on the top and bottom face are merged together, and each bridge edge is compressed to a dot, then the number of connected components is 4 if there are no edges, and is reduced by one for each edge added until there is only one component left. </p>
<p style="text-indent:40px;">The number of ways for a cube to be colored, such that it collapses to a particular square, is multiplied by 3 for each edge in the square. </p>
<p style="text-indent:40px;">To calculate the number of colorings, there are 5 cases:</p>
<p style="text-indent:80px;"><tt>0 edges (4 components): there is 1 way for this to happen.</tt></p>
<p style="text-indent:80px;"><tt>1 edge (3 components): 4 squares, each unflattens to 3 cubes, 4*3 = 12.</tt></p>
<p style="text-indent:80px;"><tt>2 edges (2 components): 6 squares, each unflattens to 3*3 = 9 cubes, 6*9 = 54.</tt></p>
<p style="text-indent:80px;"><tt>3 edges (1 component): 4 squares, each unflattens to 3*3*3 = 27 cubes, 4*27 = 108.</tt></p>
<p style="text-indent:80px;"><tt>4 edges (1 component): 1 square, which unflattens to 3*3*3*3 = 81 cubes.</tt></p>
<p style="text-indent:40px;">For the whole cube with four colored bridges there are this many colorings of each type:</p>
<p style="text-indent:80px;"><tt>1 CC: 189</tt></p>
<p style="text-indent:80px;"><tt>2 CC: 54</tt></p>
<p style="text-indent:80px;"><tt>3 CC: 12</tt></p>
<p style="text-indent:80px;"><tt>4 CC: 1</tt></p>
<h2>Cube with any number of bridges</h2>
<p style="text-indent:40px;">By adding up the number of colorings with a given number of connected components across all the prior cases, and multiplying each one by the appropriate symmetry number, we can get the overall totals:</p>
<p style="text-indent:80px;"><tt>0 CC: 1</tt></p>
<p style="text-indent:80px;"><tt>1 CC: 26+4*121+4*160+2*175+4*186+189 = 2433</tt></p>
<p style="text-indent:80px;"><tt>2 CC: 173+4*110+4*80+2*81+4*61+54 = 1393</tt></p>
<p style="text-indent:80px;"><tt>3 CC: 52+4*25+4*15+4*9+12 = 260</tt></p>
<p style="text-indent:80px;"><tt>4 CC: 4+4*1+1 = 9</tt></p>
<p style="text-indent:40px;">As a checksum, we can verify that this adds up to 4096, which is the total number of colorings of the edges of the cube. The prior calculations can all also be verified as adding up to powers of 2.</p>
<h1>Rotationally connected components (in progress)</h1>
<p style="text-indent:40px;">There are substantially fewer ways to color a cube that are rotationally symmetric.</p>
<p style="text-indent:40px;">If the coloring is to be symmetric with respect to a 90° rotation around a face of the cube, there are only 2^3 = 8 possible colorings. There are 6 faces and 2 directions to rotate in, so there are 12 instances of this type of rotation.</p>
<svg id="svg_rot_face_90" height="0" width="0" xmlns="http://www.w3.org/2000/svg">
<p style="text-indent:40px;">If the coloring is to be symmetric with respect to a 180° rotation around a face of the cube, there are 2^6 = 64 possible colorings. There are 6 faces and the direction of rotation does not matter, so there are 6 instances of this type of rotation.</p>
<svg id="svg_rot_face_180" height="0" width="0" xmlns="http://www.w3.org/2000/svg">



<p style="text-indent:40px;"></p>
<p style="text-indent:80px;"><tt></tt></p>

</body>
<script>

/*
Topic: Number of colorings of the edges of a cube that are connected vs disconnected
High level: This can be resolved by splitting the cube up into three sections (face, 4 bridge edges, face) and treating them symmetrically by cases. This also combines well with working out the number of rotationally distinct families of colorings. 
Details:
 - 0-bridge case: there is 1 empty coloring for a face, 2 disconnected, and 13 connected, for a total of 16. (1E+13C+2D)(1E+13C+2D) = 1EE+13EC+2ED+13CE+169CC+26CD+2DE+26DC+4DD = 1EE+13(EC+CE)+(2(ED+DE)+26(CD+DC)+169CC+4DD) where the first group is empty, the second group is connected, and the third is disconnected
 - 1-bridge case: this can happen four equivalent ways. 
 - 2-bridge adjacent case: this can happen four equivalent ways. there are (1C+1D)(1C+1D) = 1CC+1(CD+DC)+1DD = 3C+1D ways for the two bridges to be directly connected, and (1C+6D+1F) ways to be indirectly connected on a single face where F indicates a single edge floating by itself, for a total of (1C+1D)(1C+6D+1F) = 1CC+6CD+1CF+1DC+6DD+1DF = 8C+6D+2F for each face and (8C+6D+2F)(8C+6D+2F) = 64CC+36DD+4FF+48(DC+CD)+16(CF+FC)+12(DF+FD) = 160C+96D overall
 - 2-bridge opposite case: this can happen two equivalent ways. going around the cube in one direction, there are two edges on each face, which can be disconnected in 3x3=9 ways, with 16-9=7 ways to be connected, giving (1C+3D)(1C+3D) = 1CC+3(CD+DC)+9DD = 7C+9D. as these are independent, there are (7C+9D)(7C+9D) = 49CC+63(CD+DC)+81DD cases where at least 1 C means overall connected, and 2 D's means overall disconnected
 - 3-bridge case: this can happen four equivalent ways. for the two pairs of bridges which are adjacent, they are either connected (3 ways) or not connected (1 way) by the edges directly between them, independently. For the pair of bridges which are not adjacent and the remaining 4 edges, there is one way to connect them together on each face and 3 ways to be disconnected, giving (1C+3D)(1C+3D) = 1CC+3(CD+DC)+9DD = 7C+9D because they are connected if they are connected on at least one face. Combining these independent cases gives (3C+1D)(3C+1D)(7C+9D) = 63CCC+81CCD+21CDC+27CDD+21DCC+27DCD+7DDC+9DDD, where instances with at least 2 C's are overall connected and instances with at least 2 D's are overall disconnected
 - 4-bridge case: any two adjacent bridges are either connected (3 ways) or not connected (1 way) by the edges directly between them, independently. flattening the entire cube into one face, there are 5 cases
   - 0 edges: there is 1 way for this to happen, and it is disconnected
   - 1 edge: there are 4 ways for this to happen, each of which unflatten to 3 cases, for a total of 12, which are all disconnected
   - 2 edge: there are 6 ways for this to happen, each of which unflattens to 9 cases, for a total of 54, which are all disconnected
   - 3 edge: there are 4 ways for this to happen, each of which unflatten to 27 cases, for a total of 108, which are all connected
   - 4 edge: there is 1 way for this to happen, which unflattens to 81 cases, which are all connected
 - Total: (1E+26C+229D)+4*()+4*()+2*(175C+81D)+4*(186C+70D)+(189C+67D) = 
// TODO: finish 1-bridge case and totals, review and consider ways to make the argument simpler/cleaner, extend to the case of 2/3/4 connected components, integrate with rotational symmetries to get complete solution
*/

// TODO: list out rotation matrices (done)
// TODO: create cube data structure
// TODO: function to apply rotation matrix to cube
// TODO: function to compare cubes
// TODO: function to loop over possible cubes and compare them
// TODO: list of unique cubes
// TODO: display cube in simplified form in svg (done)
// TODO: display array of cubes in simplified form in svg
// TODO: filter cubes to remove disconnected, empty, full, 2D cases
// TODO: verify each rotation matrix by applying it to its axis vector and checking that there is no change
// TODO: create a loop that counts a numeric variable up but then interprets each bit as a flag for each edge in a cube


rotIdentity = 
 [[ 1, 0, 0],
  [ 0, 1, 0],
  [ 0, 0, 1]]
rotX90 = 
 [[ 1, 0, 0],
  [ 0, 0,-1],
  [ 0, 1, 0]]
rotX180 = 
 [[ 1, 0, 0],
  [ 0,-1, 0],
  [ 0, 0,-1]]
rotX270 = 
 [[ 1, 0, 0],
  [ 0, 0, 1],
  [ 0,-1, 0]]
rotY90 = 
 [[ 0, 0,-1],
  [ 0, 1, 0],
  [ 1, 0, 0]]
rotY180 = 
 [[-1, 0, 0],
  [ 0, 1, 0],
  [ 0, 0,-1]]
rotY270 = 
 [[ 0, 0, 1],
  [ 0, 1, 0],
  [-1, 0, 0]]
rotZ90 = 
 [[ 0,-1, 0],
  [ 1, 0, 0],
  [ 0, 0, 1]]
rotZ180 = 
 [[-1, 0, 0],
  [ 0,-1, 0],
  [ 0, 0, 1]]
rotZ270 = 
 [[ 0, 1, 0],
  [-1, 0, 0],
  [ 0, 0, 1]]
rotEdgeXPos = 
 [[-1, 0, 0],
  [ 0, 0, 1],
  [ 0, 1, 0]]
rotEdgeXNeg = 
 [[-1, 0, 0],
  [ 0, 0,-1],
  [ 0,-1, 0]]
rotEdgeYPos = 
 [[ 0, 0, 1],
  [ 0,-1, 0],
  [ 1, 0, 0]]
rotEdgeYNeg = 
 [[ 0, 0,-1],
  [ 0,-1, 0],
  [-1, 0, 0]]
rotEdgeZPos = 
 [[ 0, 1, 0],
  [ 1, 0, 0],
  [ 0, 0,-1]]
rotEdgeZNeg = 
 [[ 0,-1, 0],
  [-1, 0, 0],
  [ 0, 0,-1]]
rotCornerXYZ120 = 
 [[ 0, 0, 1],
  [ 1, 0, 0],
  [ 0, 1, 0]]
rotCornerXYZ240 = 
 [[ 0, 1, 0],
  [ 0, 0, 1],
  [ 1, 0, 0]]
rotCornerX120 = 
 [[ 0, 0,-1],
  [-1, 0, 0],
  [ 0, 1, 0]]
rotCornerX240 = 
 [[ 0,-1, 0],
  [ 0, 0, 1],
  [-1, 0, 0]]
rotCornerY120 = 
 [[ 0, 0, 1],
  [-1, 0, 0],
  [ 0,-1, 0]]
rotCornerY240 = 
 [[ 0,-1, 0],
  [ 0, 0,-1],
  [ 1, 0, 0]]
rotCornerZ120 = 
 [[ 0, 0,-1],
  [ 1, 0, 0],
  [ 0,-1, 0]]
rotCornerZ240 = 
 [[ 0, 1, 0],
  [ 0, 0,-1],
  [-1, 0, 0]]

rotations = 
 [rotIdentity,
  rotX90,
  rotX180,
  rotX270,
  rotY90,
  rotY180,
  rotY270,
  rotZ90,
  rotZ180,
  rotZ270,
  rotEdgeXPos,
  rotEdgeXNeg,
  rotEdgeYPos,
  rotEdgeYNeg,
  rotEdgeZPos,
  rotEdgeZNeg,
  rotCornerXYZ120,
  rotCornerXYZ240,
  rotCornerX120,
  rotCornerX240,
  rotCornerY120,
  rotCornerY240,
  rotCornerZ120,
  rotCornerZ240]

completeCube = 
 [[[0,1,0],
   [1,0,1],
   [0,1,0]],
  [[1,0,1],
   [0,0,0],
   [1,0,1]],
  [[0,1,0],
   [1,0,1],
   [0,1,0]]]

cubeEdgeCoordinates = 
 [[0,0,1],
  [0,1,0],
  [0,1,2],
  [0,2,1],
  [1,0,0],
  [1,0,2],
  [1,2,0],
  [1,2,2],
  [2,0,1],
  [2,1,0],
  [2,1,2],
  [2,2,1]]

cubeEdgeCoordinates2 = 
 [[ 6,[-1,-1, 0]],
  [ 5,[-1, 0,-1]],
  [12,[-1, 0, 1]],
  [10,[-1, 1, 0]],
  [11,[ 0,-1,-1]],
  [ 1,[ 0,-1, 1]],
  [ 4,[ 0, 1,-1]],
  [ 8,[ 0, 1, 1]],
  [ 7,[ 1,-1, 0]],
  [ 9,[ 1, 0,-1]],
  [ 2,[ 1, 0, 1]],
  [ 3,[ 1, 1, 0]]]

cubeEdgeIndices = 
 [[[ 0, 0, 0],
   [ 1, 0, 2],
   [ 0, 3, 0]],
  [[ 4, 0, 5],
   [ 0, 0, 0],
   [ 6, 0, 7]],
  [[ 0, 8, 0],
   [ 9, 0,10],
   [ 0,11, 0]]]

neighborIndices =
 [[1,2,4,5],
  [0,3,4,6],
  [0,3,5,7],
  [1,2,6,7],
  [0,1,8,9],
  [0,2,8,10],
  [1,3,9,11],
  [2,3,10,11],
  [4,5,9,10],
  [4,6,8,11],
  [5,7,8,11],
  [6,7,9,10]]

function cubeEdgeToIndex(edge) {
	let newEdge = cubeEdgeIndices[edge[0]+1][edge[1]+1][edge[2]+1];
	return newEdge
}

function cubeIndexToEdge(index) {
	return cubeEdgeCoordinates2[index][1];
}

function applyRotationToEdge(matrix,edge) {
	let newEdge = [0,0,0];
	for(let r=0; r<3; r++) {
		let tmp = 0;
		for(let c=0; c<3; c++) {
			tmp += matrix[r][c]*edge[c];
		}
		newEdge[r] = tmp;
	}
	return newEdge;
}

function applyRotationToIndex(matrix,index) {
	let edge = cubeIndexToEdge(index);
	let newEdge = applyRotationToEdge(matrix,edge);
	let newIndex = cubeEdgeToIndex(newEdge);
	return newIndex;
}

function cubeToIndices(cube) {
	let indices = [0,0,0,0,0,0,0,0,0,0,0,0];
	for(let k=0; k<12; k++) {
		let bit = (cube>>k)&1;
		if(bit==1) {
			indices[k] = 1;
		}
	}
	return indices;
}

function indicesToCube(indices) {
	let cube = 0;
	for(let k=0; k<12; k++) {
		let bit = indices[k];
		cube = cube|(bit<<k);
	}
	return cube;
}

function rotateCube(matrix,cube) {
	let indices = cubeToIndices(cube);
	let newIndices = [0,0,0,0,0,0,0,0,0,0,0,0];
	for(let k=0; k<12; k++) {
		let bit = indices[k];
		if(bit) {
			let newIndex = applyRotationToIndex(matrix,k);
			newIndices[newIndex] = 1;
		}
	}
	let newCube = indicesToCube(newIndices);
	return newCube;
}

function displayCube(bits) {
	for(let k=0; k<12; k++) {
		let edgeId = cubeEdgeCoordinates2[k][0];
		let bit = (bits>>k)&1;
		if(bit==1) {
			document.getElementById("e"+edgeId).style.opacity = "1";
		} else {
			document.getElementById("e"+edgeId).style.opacity = "0";
		}
	}
}

function displayRandomCube() {
	displayCube(Math.floor(Math.random()*4096));
}

//displayRandomCube();
//displayCube(rotateCube(rotations[23],14));

let distinctCubes = [];

function iterateOverCubes() {
	for(let bits=0; bits<4096; bits++) {
		let duplicate = 0;
		for(let rotationIndex=0; rotationIndex<24; rotationIndex++) {
			rotation = rotations[rotationIndex];
			let newBits = rotateCube(rotation,bits);
			if(distinctCubes.includes(newBits)) {
				duplicate = 1;
				continue;
			}
		}
		if(duplicate==0) {
			distinctCubes.push(bits);
		}
	}
	console.log(distinctCubes.length);
}

iterateOverCubes();

//displayCube(distinctCubes[175]);

function cubePointToScreenPointAsHexagon(x,y,z,xmax) {
	// 0,0,0 on the cube maps to 0,0 on the screen
	// -1,1,1 and 1,-1,-1 on the cube map to 0,0 on the screen
	// screen points will be within ([-xmax,xmax],[-xmax,xmax]) bounding box
	let r3 = 1.732;
	let screenPoint = [0,0];
	screenPoint[0] = Math.round((0.5*x+0.25*y+0.25*z)*xmax);
	screenPoint[1] = Math.round((0.0*x+0.25*r3*y-0.25*r3*z)*xmax);
	return screenPoint;
}

function cubePointToScreenPointAsSquare(x,y,z,xmax) {
	// 0,0,0 on the cube maps to 0,0 on the screen
	// 0,0,1 and 0,0,-1 on the cube map to 0,0 on the screen
	// screen points will be within ([-xmax,xmax],[-xmax,xmax]) bounding box
	let screenPoint = [0,0];
	screenPoint[0] = Math.round(x*(0.66+0.33*z)*xmax);
	screenPoint[1] = Math.round(y*(0.66+0.33*z)*xmax);
	return screenPoint;
}

function paintCorner(svg,x,y,z,offsetX,offsetY,size) {
	//let screenPoint = cubePointToScreenPointAsHexagon(x,y,z,size);
	let screenPoint = cubePointToScreenPointAsSquare(x,y,z,size);
	let circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
	svg.appendChild(circle);
	//circle.setAttribute("r","2");
	circle.setAttribute("r","1");
	circle.setAttribute("cx",""+(screenPoint[0]+offsetX));
	circle.setAttribute("cy",""+(screenPoint[1]+offsetY));
	circle.setAttribute("fill","black");
}

function paintEdge(svg, edge, offsetX, offsetY, size) {
	let x1 = edge[0]==0?-1:edge[0];
	let y1 = edge[1]==0?-1:edge[1];
	let z1 = edge[2]==0?-1:edge[2];
	let x2 = edge[0]==0?1:edge[0];
	let y2 = edge[1]==0?1:edge[1];
	let z2 = edge[2]==0?1:edge[2];
	//let screenPoint1 = cubePointToScreenPointAsHexagon(x1,y1,z1,size);
	//let screenPoint2 = cubePointToScreenPointAsHexagon(x2,y2,z2,size);
	let screenPoint1 = cubePointToScreenPointAsSquare(x1,y1,z1,size);
	let screenPoint2 = cubePointToScreenPointAsSquare(x2,y2,z2,size);
	let polygon = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
	svg.appendChild(polygon);
	polygon.setAttribute("style", "fill:black;stroke:black;stroke-width:1");
	let point1 = svg.createSVGPoint();
	point1.x = screenPoint1[0]+offsetX;
	point1.y = screenPoint1[1]+offsetY;
	polygon.points.appendItem(point1);
	let point2 = svg.createSVGPoint();
	point2.x = screenPoint2[0]+offsetX;
	point2.y = screenPoint2[1]+offsetY;
	polygon.points.appendItem(point2);
}

function paintSquare(svg, left, top, right, bottom, offsetX, offsetY, size) {
	if(left) {
		paintEdge(svg,[-1,0,1],offsetX,offsetY,size);
	}
	if(right) {
		paintEdge(svg,[1,0,1],offsetX,offsetY,size);
	}
	if(top) {
		paintEdge(svg,[0,-1,1],offsetX,offsetY,size);
	}
	if(bottom) {
		paintEdge(svg,[0,1,1],offsetX,offsetY,size);
	}
	for(let x=-1; x<=1; x+=2) {
		for(let y=-1; y<=1; y+=2) {
			paintCorner(svg,x,y,1,offsetX,offsetY,size);
		}
	}
}
function paintCube(svg, cube, offsetX, offsetY, size) {
	let indices = cubeToIndices(cube);
	for(let k=0; k<12; k++) {
		let bit = indices[k];
		if(bit) {
			let edge = cubeEdgeCoordinates2[k][1];
			paintEdge(svg,edge,offsetX,offsetY,size);
		}
	}
	for(let x=-1; x<=1; x+=2) {
		for(let y=-1; y<=1; y+=2) {
			for(let z=-1; z<=1; z+=2) {
				paintCorner(svg,x,y,z,offsetX,offsetY,size);
			}
		}
	}
}

function paintAllDistinctCubes(svg) {
	for(let c=0; c<15; c++) {
		for(let r=0; r<15; r++) {
			if(c*15+r>=distinctCubes.length) break;
			paintCube(svg,distinctCubes[c*15+r],r*40+20,c*40+20,10);
		}
	}
}

//paintAllDistinctCubes()

function countNumberOfEdges(bits) {
	let indices = cubeToIndices(bits);
	let numberOfEdges = 0;
	for(let k=0; k<12; k++) {
		if(indices[k]==1) {
			numberOfEdges++;
		}
	}
	return numberOfEdges;
}

function countNumberOfConnectedComponents(bits) {
	let indices = cubeToIndices(bits);
	let visited = [0,0,0,0,0,0,0,0,0,0,0,0];
	let numberOfConnectedComponents = 0;
	while(true) {
		let finished = 1;
		for(let k=0; k<12; k++) {
			if(indices[k]==1&&visited[k]==0) {
				finished = 0;
				numberOfConnectedComponents++;
				visited[k] = 1;
				break;
			}
		}
		if(finished==1) break;
		while(true) {
			let componentFinished = 1;
			for(let k=0; k<12; k++) {
				if(indices[k]==0) continue;
				if(visited[k]==1) {
					visited[k] = 2;
					componentFinished = 0;
					let neighbors = neighborIndices[k];
					for(let n=0; n<neighbors.length; n++) {
						let neighbor = neighbors[n];
						if(indices[neighbor]==0) continue;
						if(visited[neighbor]==0) {
							visited[neighbor] = 1;
						}
					}
				}
			}
			if(componentFinished==1) break;
		}
	}
	return numberOfConnectedComponents;
}

// stratified by number of connected components and then number of edges
let stratifiedCubes = 
 [[[],[],[],[],[],[],[],[],[],[],[],[],[]],
  [[],[],[],[],[],[],[],[],[],[],[],[],[]],
  [[],[],[],[],[],[],[],[],[],[],[],[],[]],
  [[],[],[],[],[],[],[],[],[],[],[],[],[]],
  [[],[],[],[],[],[],[],[],[],[],[],[],[]]]

function stratifyDistinctCubes() {
	for(let k=0; k<distinctCubes.length; k++) {
		let bits = distinctCubes[k];
		let numberOfEdges = countNumberOfEdges(bits);
		let numberOfConnectedComponents = countNumberOfConnectedComponents(bits);
		stratifiedCubes[numberOfConnectedComponents][numberOfEdges].push(bits);
	}
}

stratifyDistinctCubes();

console.log(stratifiedCubes);


function paintLine(svg,p1,p2) {
	let line = document.createElementNS("http://www.w3.org/2000/svg", "line");
	line.setAttribute("style", "stroke:black;stroke-width:1");
	svg.appendChild(line);
	line.setAttribute("x1",p1[0]);
	line.setAttribute("y1",p1[1]);
	line.setAttribute("x2",p2[0]);
	line.setAttribute("y2",p2[1]);
}

function paintText(svg,x,y,textContent) {
	let text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
	text.setAttribute('x',x);
	text.setAttribute('y',y);
	text.setAttribute('fill','#000');
	text.setAttribute("style","font-size:20px;");
	text.textContent = textContent;
	svg.appendChild(text); 
}

function paintFrame(svg,width,height) {
	paintLine(svg,[0,0],[width,0]);
	paintLine(svg,[width,0],[width,height]);
	paintLine(svg,[width,height],[0,height]);
	paintLine(svg,[0,height],[0,0]);
}

function paintAllDistinctStratifiedCubes(svg,svgh,numberOfEdges) {
	// TODO: swap r and c for readability?
	let r = -1;
	let c = -2;
	let numberOfCubes = 0;
	for(let numberOfConnectedComponents=0; numberOfConnectedComponents<5; numberOfConnectedComponents++) {
		let cubes = stratifiedCubes[numberOfConnectedComponents][numberOfEdges];
		if(cubes.length>0) {
			c += 2;
			r = -1;
			let componentsText = numberOfConnectedComponents==1?" Connected component":" Connected components";
			paintText(svg,10,c*40+30,numberOfConnectedComponents+componentsText+" ("+cubes.length+" cube"+(cubes.length==1?"":"s")+")");
			for(let k=0; k<cubes.length; k++) {
				r++;
				if(r==15) {
					r = 0;
					c++;
				}
				paintCube(svg,cubes[k],r*40+20,(c+1)*40+20,10);
				numberOfCubes++;
			}
		}
	}
	let h = (c+2)*40+10;
	svg.setAttribute('width','800');
	svg.setAttribute('height',h);
	paintFrame(svg,800,h);
	svgh.innerText = "Rotationally distinct cubes with "+numberOfEdges+" edge"+(numberOfEdges==1?"":"s")+" ("+numberOfCubes+" cube"+(numberOfCubes==1?"":"s")+")";
}

// TODO: this is working even though svg0 etc are not declared variables, how standard is that across browsers?
paintAllDistinctStratifiedCubes(svg0,svgh0,0);
paintAllDistinctStratifiedCubes(svg1,svgh1,1);
paintAllDistinctStratifiedCubes(svg2,svgh2,2);
paintAllDistinctStratifiedCubes(svg3,svgh3,3);
paintAllDistinctStratifiedCubes(svg4,svgh4,4);
paintAllDistinctStratifiedCubes(svg5,svgh5,5);
paintAllDistinctStratifiedCubes(svg6,svgh6,6);
paintAllDistinctStratifiedCubes(svg7,svgh7,7);
paintAllDistinctStratifiedCubes(svg8,svgh8,8);
paintAllDistinctStratifiedCubes(svg9,svgh9,9);
paintAllDistinctStratifiedCubes(svg10,svgh10,10);
paintAllDistinctStratifiedCubes(svg11,svgh11,11);
paintAllDistinctStratifiedCubes(svg12,svgh12,12);

function paintAllDistinctStratifiedSquares(svg) {
	paintText(svg,10,30,"0 Connected components (1 square)");
	paintSquare(svg,false,false,false,false,30,60,10);
	paintText(svg,10,110,"1 Connected component (13 squares)");
	paintSquare(svg,true,false,false,false,30,140,10);
	paintSquare(svg,false,true,false,false,70,140,10);
	paintSquare(svg,false,false,true,false,110,140,10);
	paintSquare(svg,false,false,false,true,150,140,10);
	paintSquare(svg,true,true,false,false,190,140,10);
	paintSquare(svg,false,true,true,false,230,140,10);
	paintSquare(svg,false,false,true,true,270,140,10);
	paintSquare(svg,true,false,false,true,310,140,10);
	paintSquare(svg,true,true,true,false,350,140,10);
	paintSquare(svg,false,true,true,true,390,140,10);
	paintSquare(svg,true,false,true,true,430,140,10);
	paintSquare(svg,true,true,false,true,470,140,10);
	paintSquare(svg,true,true,true,true,510,140,10);
	paintText(svg,10,190,"2 Connected components (2 squares)");
	paintSquare(svg,true,false,true,false,30,220,10);
	paintSquare(svg,false,true,false,true,70,220,10);
	svg.setAttribute('width','800');
	svg.setAttribute('height','250');
	paintFrame(svg,800,250);
}
// TODO: indent to match other content
paintAllDistinctStratifiedSquares(svg_square);

function paintOneBridgeCubes(svg) {
	paintText(svg,10,30,"1 Connected component (11 squares)");
	paintCube(svg,indicesToCube([1,0,0,0,0,0,0,0,0,0,0,0]),30,60,10);
	paintCube(svg,indicesToCube([1,0,0,0,0,1,0,0,0,0,0,0]),70,60,10);
	paintCube(svg,indicesToCube([1,0,1,0,0,0,0,0,0,0,0,0]),110,60,10);
	paintCube(svg,indicesToCube([1,0,0,0,0,1,0,0,0,0,1,0]),150,60,10);
	paintCube(svg,indicesToCube([1,0,1,0,0,1,0,0,0,0,0,0]),190,60,10);
	paintCube(svg,indicesToCube([1,0,1,0,0,0,0,1,0,0,0,0]),230,60,10);
	paintCube(svg,indicesToCube([1,0,0,0,0,1,0,1,0,0,1,0]),270,60,10);
	paintCube(svg,indicesToCube([1,0,1,0,0,1,0,1,0,0,0,0]),310,60,10);
	paintCube(svg,indicesToCube([1,0,1,0,0,1,0,0,0,0,1,0]),350,60,10);
	paintCube(svg,indicesToCube([1,0,1,0,0,0,0,1,0,0,1,0]),390,60,10);
	paintCube(svg,indicesToCube([1,0,1,0,0,1,0,1,0,0,1,0]),430,60,10);
	paintText(svg,10,110,"2 Connected components (5 squares)");
	paintCube(svg,indicesToCube([1,0,0,0,0,0,0,1,0,0,0,0]),30,140,10);
	paintCube(svg,indicesToCube([1,0,0,0,0,0,0,0,0,0,1,0]),70,140,10);
	paintCube(svg,indicesToCube([1,0,0,0,0,0,0,1,0,0,1,0]),110,140,10);
	paintCube(svg,indicesToCube([1,0,1,0,0,0,0,0,0,0,1,0]),150,140,10);
	paintCube(svg,indicesToCube([1,0,0,0,0,1,0,1,0,0,0,0]),190,140,10);
	svg.setAttribute('width','800');
	svg.setAttribute('height','170');
	paintFrame(svg,800,170);
}
// TODO: indent to match other content
paintOneBridgeCubes(svg_1_bridge);

function paintTwoAdjBridgeCubes(svg) {
	paintText(svg,10,30,"Bridges disconnected + 2 Connected components (6 squares)");
	paintCube(svg,indicesToCube([1,0,0,0,0,0,0,0,1,0,0,0]),30,60,10);
	paintCube(svg,indicesToCube([1,0,0,0,0,0,0,0,1,0,1,0]),70,60,10);
	paintCube(svg,indicesToCube([1,0,0,0,0,0,0,1,1,0,1,0]),110,60,10);
	paintCube(svg,indicesToCube([1,0,1,0,0,0,0,0,1,0,1,0]),150,60,10);
	paintCube(svg,indicesToCube([1,0,1,0,0,0,0,0,1,0,0,0]),190,60,10);
	paintCube(svg,indicesToCube([1,0,1,0,0,0,0,1,1,0,0,0]),230,60,10);
	paintText(svg,10,110,"Bridges disconnected + 3 Connected components (1 square)");
	paintCube(svg,indicesToCube([1,0,0,0,0,0,0,1,1,0,0,0]),30,140,10);
	paintText(svg,10,190,"Bridges connected + 1 Connected component (8 squares)");
	paintCube(svg,indicesToCube([1,0,0,0,0,1,0,0,1,0,0,0]),30,220,10);
	paintCube(svg,indicesToCube([1,0,0,0,0,1,0,0,1,0,1,0]),70,220,10);
	paintCube(svg,indicesToCube([1,0,1,0,0,1,0,0,1,0,0,0]),110,220,10);
	paintCube(svg,indicesToCube([1,0,0,0,0,1,0,1,1,0,1,0]),150,220,10);
	paintCube(svg,indicesToCube([1,0,1,0,0,1,0,1,1,0,0,0]),190,220,10);
	paintCube(svg,indicesToCube([1,0,1,0,0,1,0,0,1,0,1,0]),230,220,10);
	paintCube(svg,indicesToCube([1,0,1,0,0,0,0,1,1,0,1,0]),270,220,10);
	paintCube(svg,indicesToCube([1,0,1,0,0,1,0,1,1,0,1,0]),310,220,10);
	paintText(svg,10,270,"Bridges connected + 2 Connected components (1 square)");
	paintCube(svg,indicesToCube([1,0,0,0,0,1,0,1,1,0,0,0]),30,300,10);
	svg.setAttribute('width','800');
	svg.setAttribute('height','330');
	paintFrame(svg,800,330);
}
// TODO: indent to match other content
paintTwoAdjBridgeCubes(svg_2_adj_bridge);

function paintTwoAntiBridgeCubes(svg) {
	paintText(svg,10,30,"1 Connected component (7 squares)");
	paintCube(svg,indicesToCube([1,0,1,0,0,0,0,1,0,0,0,1]),30,60,10);
	paintCube(svg,indicesToCube([1,0,0,0,0,1,0,0,0,0,1,1]),70,60,10);
	paintCube(svg,indicesToCube([1,0,0,0,0,1,0,1,0,0,1,1]),110,60,10);
	paintCube(svg,indicesToCube([1,0,1,0,0,1,0,1,0,0,0,1]),150,60,10);
	paintCube(svg,indicesToCube([1,0,1,0,0,1,0,0,0,0,1,1]),190,60,10);
	paintCube(svg,indicesToCube([1,0,1,0,0,0,0,1,0,0,1,1]),230,60,10);
	paintCube(svg,indicesToCube([1,0,1,0,0,1,0,1,0,0,1,1]),270,60,10);
	paintText(svg,10,110,"2 Connected components (9 squares)");
	paintCube(svg,indicesToCube([1,0,0,0,0,0,0,0,0,0,0,1]),30,140,10);
	paintCube(svg,indicesToCube([1,0,0,0,0,0,0,0,0,0,1,1]),70,140,10);
	paintCube(svg,indicesToCube([1,0,1,0,0,0,0,0,0,0,0,1]),110,140,10);
	paintCube(svg,indicesToCube([1,0,0,0,0,0,0,1,0,0,0,1]),150,140,10);
	paintCube(svg,indicesToCube([1,0,0,0,0,1,0,0,0,0,0,1]),190,140,10);
	paintCube(svg,indicesToCube([1,0,0,0,0,0,0,1,0,0,1,1]),230,140,10);
	paintCube(svg,indicesToCube([1,0,1,0,0,0,0,0,0,0,1,1]),270,140,10);
	paintCube(svg,indicesToCube([1,0,1,0,0,1,0,0,0,0,0,1]),310,140,10);
	paintCube(svg,indicesToCube([1,0,0,0,0,1,0,1,0,0,0,1]),350,140,10);
	svg.setAttribute('width','800');
	svg.setAttribute('height','170');
	paintFrame(svg,800,170);
}
// TODO: indent to match other content
paintTwoAntiBridgeCubes(svg_2_anti_bridge);

function paintThreeBridgeCubes(svg) {
	paintText(svg,10,30,"1 Connected component (6 squares)");
	paintCube(svg,indicesToCube([1,0,0,0,0,1,0,0,1,0,1,1]),30,60,10);
	paintCube(svg,indicesToCube([1,0,0,0,0,1,0,1,1,0,1,1]),70,60,10);
	paintCube(svg,indicesToCube([1,0,1,0,0,1,0,1,1,0,0,1]),110,60,10);
	paintCube(svg,indicesToCube([1,0,1,0,0,1,0,0,1,0,1,1]),150,60,10);
	paintCube(svg,indicesToCube([1,0,1,0,0,0,0,1,1,0,1,1]),190,60,10);
	paintCube(svg,indicesToCube([1,0,1,0,0,1,0,1,1,0,1,1]),230,60,10);
	paintText(svg,10,110,"2 Connected components + Top connected (3 squares)");
	paintCube(svg,indicesToCube([1,0,0,0,0,1,0,0,1,0,0,1]),30,140,10);
	paintCube(svg,indicesToCube([1,0,1,0,0,1,0,0,1,0,0,1]),70,140,10);
	paintCube(svg,indicesToCube([1,0,0,0,0,1,0,1,1,0,0,1]),110,140,10);
	paintText(svg,10,190,"2 Connected components + Right connected (3 squares)");
	paintCube(svg,indicesToCube([1,0,0,0,0,0,0,0,1,0,1,1]),30,220,10);
	paintCube(svg,indicesToCube([1,0,0,0,0,0,0,1,1,0,1,1]),70,220,10);
	paintCube(svg,indicesToCube([1,0,1,0,0,0,0,0,1,0,1,1]),110,220,10);
	paintText(svg,10,270,"2 Connected components + Diagonal connected (1 square)");
	paintCube(svg,indicesToCube([1,0,1,0,0,0,0,1,1,0,0,1]),30,300,10);
	paintText(svg,10,350,"3 Connected components (3 squares)");
	paintCube(svg,indicesToCube([1,0,0,0,0,0,0,0,1,0,0,1]),30,380,10);
	paintCube(svg,indicesToCube([1,0,1,0,0,0,0,0,1,0,0,1]),70,380,10);
	paintCube(svg,indicesToCube([1,0,0,0,0,0,0,1,1,0,0,1]),110,380,10);

	svg.setAttribute('width','800');
	svg.setAttribute('height','410');
	paintFrame(svg,800,410);
}
// TODO: indent to match other content
paintThreeBridgeCubes(svg_3_bridge);

function paintRotateFace90Cubes(svg) {
	paintText(svg,10,30,"0 connected components (1 cube)");
	paintCube(svg,indicesToCube([0,0,0,0,0,0,0,0,0,0,0,0]),30,60,10);
	paintText(svg,10,110,"1 connected component (5 cubes)");
	paintCube(svg,indicesToCube([0,1,0,0,1,0,1,0,0,1,0,0]),30,140,10);
	paintCube(svg,indicesToCube([1,1,0,1,1,0,1,0,1,1,0,1]),70,140,10);
	paintCube(svg,indicesToCube([0,0,1,0,0,1,0,1,0,0,1,0]),110,140,10);
	paintCube(svg,indicesToCube([1,0,1,1,0,1,0,1,1,0,1,1]),150,140,10);
	paintCube(svg,indicesToCube([1,1,1,1,1,1,1,1,1,1,1,1]),190,140,10);
	paintText(svg,10,190,"2 connected components (1 cube)");
	paintCube(svg,indicesToCube([0,1,1,0,1,1,1,1,0,1,1,0]),30,220,10);
	paintText(svg,10,270,"4 connected components (1 cube)");
	paintCube(svg,indicesToCube([1,0,0,1,0,0,0,0,1,0,0,1]),30,300,10);
	svg.setAttribute('width','800');
	svg.setAttribute('height','330');
	paintFrame(svg,800,330);
}
paintRotateFace90Cubes(svg_rot_face_90);

function PRF180helper1(a,b,c,d,e,f) {
	let indices = [0,0,0,0,0,0,0,0,0,0,0,0];
	if(a==1) {
		indices[5] = 1;
		indices[7] = 1;
	}
	if(b==1) {
		indices[2] = 1;
		indices[10] = 1;
	}
	if(c==1) {
		indices[0] = 1;
		indices[11] = 1;
	}
	if(d==1) {
		indices[3] = 1;
		indices[8] = 1;
	}
	if(e==1) {
		indices[4] = 1;
		indices[6] = 1;
	}
	if(f==1) {
		indices[1] = 1;
		indices[9] = 1;
	}
	return indices;
}

function PRF180helper2(svg,y,index_lists) {
	for(let k=0; k<index_lists.length; k++) {
		let indices = index_lists[k];
		let x = 30+40*k;
		paintCube(svg,indicesToCube(indices),x,y,10);
	}
}

function paintRotateFace180Cubes(svg) {
	// TODO: update this with all 64 cases, consider how to automate it
	let x = 30;
	paintText(svg,10,x,"0 connected components (1 cube)");
	PRF180helper2(svg,x+30,[
		PRF180helper1(0,0,0,0,0,0)
	]);
	x += 80;
	paintText(svg,10,x,"1 connected component (25 cubes)");
	PRF180helper2(svg,x+30,[
		PRF180helper1(0,0,0,0,1,1),
		PRF180helper1(0,0,0,1,1,1),
		PRF180helper1(0,0,1,0,1,1),
		PRF180helper1(0,0,1,1,1,1),
		PRF180helper1(0,1,0,1,1,1),
		PRF180helper1(0,1,1,0,1,1),
		PRF180helper1(0,1,1,1,1,0),
		PRF180helper1(0,1,1,1,1,1),
		PRF180helper1(1,0,0,1,1,1),
		PRF180helper1(1,0,1,0,1,1),
		PRF180helper1(1,0,1,1,0,1),
		PRF180helper1(1,0,1,1,1,1),
		PRF180helper1(1,1,0,0,0,0),
		PRF180helper1(1,1,0,1,0,0),
		PRF180helper1(1,1,0,1,0,1),
	]);
	x += 40;
	PRF180helper2(svg,x+30,[
		PRF180helper1(1,1,0,1,1,0),
		PRF180helper1(1,1,0,1,1,1),
		PRF180helper1(1,1,1,0,0,0),
		PRF180helper1(1,1,1,0,0,1),
		PRF180helper1(1,1,1,0,1,0),
		PRF180helper1(1,1,1,0,1,1),
		PRF180helper1(1,1,1,1,0,0),
		PRF180helper1(1,1,1,1,0,1),
		PRF180helper1(1,1,1,1,1,0),
		PRF180helper1(1,1,1,1,1,1),
	]);
	x += 80;
	paintText(svg,10,x,"2 connected components (29 cubes)");
	PRF180helper2(svg,x+30,[
		PRF180helper1(0,0,0,0,0,1),
		PRF180helper1(0,0,0,0,1,0),
		PRF180helper1(0,0,0,1,0,0),
		PRF180helper1(0,0,0,1,0,1),
		PRF180helper1(0,0,0,1,1,0),
		PRF180helper1(0,0,1,0,0,0),
		PRF180helper1(0,0,1,0,0,1),
		PRF180helper1(0,0,1,0,1,0),
		PRF180helper1(0,0,1,1,0,1),
		PRF180helper1(0,0,1,1,1,0),
		PRF180helper1(0,1,0,0,0,0),
		PRF180helper1(0,1,0,1,0,0),
		PRF180helper1(0,1,0,1,0,1),
		PRF180helper1(0,1,0,1,1,0),
		PRF180helper1(0,1,1,0,0,0),
	]);
	x += 40;
	PRF180helper2(svg,x+30,[
		PRF180helper1(0,1,1,0,0,1),
		PRF180helper1(0,1,1,0,1,0),
		PRF180helper1(0,1,1,1,0,0),
		PRF180helper1(0,1,1,1,0,1),
		PRF180helper1(1,0,0,0,0,0),
		PRF180helper1(1,0,0,1,0,0),
		PRF180helper1(1,0,0,1,0,1),
		PRF180helper1(1,0,0,1,1,0),
		PRF180helper1(1,0,1,0,0,0),
		PRF180helper1(1,0,1,0,0,1),
		PRF180helper1(1,0,1,0,1,0),
		PRF180helper1(1,0,1,1,0,0),
		PRF180helper1(1,0,1,1,1,0),
		PRF180helper1(1,1,0,0,1,1),
	]);
	x += 80;
	paintText(svg,10,x,"3 connected components (4 cubes)");
	PRF180helper2(svg,x+30,[
		PRF180helper1(1,0,0,0,1,1),
		PRF180helper1(1,1,0,0,0,1),
		PRF180helper1(1,1,0,0,1,0),
		PRF180helper1(0,1,0,0,1,1),
	]);
	x += 80;
	paintText(svg,10,x,"4 connected components (5 cubes)");
	PRF180helper2(svg,x+30,[
		PRF180helper1(0,0,1,1,0,0),
		PRF180helper1(0,1,0,0,0,1),
		PRF180helper1(0,1,0,0,1,0),
		PRF180helper1(1,0,0,0,0,1),
		PRF180helper1(1,0,0,0,1,0),
	]);
	svg.setAttribute('width','800');
	svg.setAttribute('height','490');
	paintFrame(svg,800,490);
}
paintRotateFace180Cubes(svg_rot_face_180);


// TODO: color code the corners by how many edges they are adjacent to
// TODO: color code the edges by whether they are connected to leaves or between branch points
// TODO: color code edges that are the middle of a C shape
// TODO: color code corners that are adjacent to two edges and are one edge in from an endpoint and twist clockwise coming from that direction (to tell apart mirror images)

</script>
</html>