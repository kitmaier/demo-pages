<html>
<head>
<style>
table, th, tr, td {
  border: 1px solid;
  font-family: monospace;
}
th {
  font-weight: bold;
}
</style>
</head>
<body>
<h1>How many incomplete cubes are there?</h1>
<p style="text-indent:40px;">This investigation was inspired by a <a href="https://www.youtube.com/watch?v=_BrFKp-U8GI">3Blue1Brown guest video</a> written by Paul Dancstep.</p>
<p style="text-indent:40px;">The question presented in the video is, how many distinct subsets of the set of edges of a cube are there, or how many colorings of the edges of a cube are there, given the following constraints:</p>
<p style="text-indent:80px;"><tt>1) The colored edges must be connected.</tt></p>
<p style="text-indent:80px;"><tt>2) Rotationally equivalent colorings are excluded.</tt></p>
<p style="text-indent:80px;"><tt>3) Colorings that fit within a plane or on one side of the cube are excluded.</tt></p>
<p style="text-indent:80px;"><tt>4) The empty coloring and complete coloring are excluded.</tt></p>
<p style="text-indent:40px;">These guidelines will be modified slightly here. Instead of looking only at connected cubes, we will look at cubes with various numbers of connected colored components, and will not worry much about points 3 and 4. </p>
<p style="text-indent:40px;">First there will be an automated enumeration of all the cubes, and then a theoretical discussion.</p>
<p style="text-indent:40px;">In total there are:</p>
<p style="text-indent:80px;"><tt>1 cube with 0 components</tt></p>
<p style="text-indent:80px;"><tt>127 cubes with 1 component</tt></p>
<p style="text-indent:80px;"><tt>72 cubes with 2 components</tt></p>
<p style="text-indent:80px;"><tt>16 cubes with 3 components</tt></p>
<p style="text-indent:80px;"><tt>2 cubes with 4 components</tt></p>
<p style="text-indent:80px;"><tt>218 cubes overall</tt></p>
<h1 id="svgh0">Rotationally distinct cubes with 0 edges</h1>
<svg id="svg0" height="0" width="0" xmlns="http://www.w3.org/2000/svg">
<h1 id="svgh1">Rotationally distinct cubes with 1 edge</h1>
<svg id="svg1" height="0" width="0" xmlns="http://www.w3.org/2000/svg">
<h1 id="svgh2">Rotationally distinct cubes with 2 edges</h1>
<svg id="svg2" height="0" width="0" xmlns="http://www.w3.org/2000/svg">
<h1 id="svgh3">Rotationally distinct cubes with 3 edges</h1>
<svg id="svg3" height="0" width="0" xmlns="http://www.w3.org/2000/svg">
<h1 id="svgh4">Rotationally distinct cubes with 4 edges</h1>
<svg id="svg4" height="0" width="0" xmlns="http://www.w3.org/2000/svg">
<h1 id="svgh5">Rotationally distinct cubes with 5 edges</h1>
<svg id="svg5" height="0" width="0" xmlns="http://www.w3.org/2000/svg">
<h1 id="svgh6">Rotationally distinct cubes with 6 edges</h1>
<svg id="svg6" height="0" width="0" xmlns="http://www.w3.org/2000/svg">
<h1 id="svgh7">Rotationally distinct cubes with 7 edges</h1>
<svg id="svg7" height="0" width="0" xmlns="http://www.w3.org/2000/svg">
<h1 id="svgh8">Rotationally distinct cubes with 8 edges</h1>
<svg id="svg8" height="0" width="0" xmlns="http://www.w3.org/2000/svg">
<h1 id="svgh9">Rotationally distinct cubes with 9 edges</h1>
<svg id="svg9" height="0" width="0" xmlns="http://www.w3.org/2000/svg">
<h1 id="svgh10">Rotationally distinct cubes with 10 edges</h1>
<svg id="svg10" height="0" width="0" xmlns="http://www.w3.org/2000/svg">
<h1 id="svgh11">Rotationally distinct cubes with 11 edges</h1>
<svg id="svg11" height="0" width="0" xmlns="http://www.w3.org/2000/svg">
<h1 id="svgh12">Rotationally distinct cubes with 12 edges</h1>
<svg id="svg12" height="0" width="0" xmlns="http://www.w3.org/2000/svg">
</svg>
<h1>How could this be calculated without a computer? (in progress)</h1>
<p style="text-indent:40px;">There is a detailed discussion in the video linked above of how to use group theory to calculate the number of rotationally distinct cubes.</p>
<p style="text-indent:40px;">However, this does not take into account the number of connected components.</p>
<p style="text-indent:40px;">Below both will be explained in more detail.</p>
<h1>Rotational groups (in progress)</h1>
<p style="text-indent:40px;">If a coloring of a cube has no symmetries, then there are 24 different rotated versions of that cube. </p>
<!-- TODO: insert some diagrams here -->
<p style="text-indent:40px;">If the cube does have symmetries, then the number of distinct rotated versions of the cube is a divisor of 24. </p>
<p style="text-indent:40px;">It turns out that the number of rotationally distinct cubes can be calculated by starting with the number of colorings of the cube, adding in the number of symmetric colorings to make up for undercounting, and then dividing by 24 to account for rotations. </p>
<!-- TODO: give the example of a square -->
<h1>Cube Rotation Group Representation (in progress)</h1>
<p style="text-indent:40px;">The group of rotations of a cube can be represented compactly as a set of 24 rotation matrices, which is how the automated enumeration of the cubes was implemented.</p>
<p style="text-indent:40px;">If the corners of each cube are aligned to the points (+/-1,+/-1,+/-1), then the matrices representing the rotational symmetries of the cube all have terms that are 1, 0, and -1. </p>
<p style="text-indent:40px;">This group is also the group of <a href="https://en.wikipedia.org/wiki/Octahedral_symmetry">rotational symmetries of the octahedron</a>. </p>
<!-- TODO: generate two-dimensional array of cube diagrams showing a square with an attached edge rotating around to each face of the cube, and align the rotational matrices with that array -->
<!-- TODO: generate a grouping of cube diagrams showing n-fold rotation around each face/edge/corner, and align the rotational matrices with that array -->
<table id="configsTable" style="width:600px;margin-left:80px;text-align:center;">
	<tr>
		<th>
			[ 1, 0, 0]<br/>
			[ 0, 1, 0]<br/>
			[ 0, 0, 1]
		</th>
		<th>
			[ 1, 0, 0]<br/>
			[ 0, 0,-1]<br/>
			[ 0, 1, 0]
		</th>
		<th>
			[ 1, 0, 0]<br/>
			[ 0,-1, 0]<br/>
			[ 0, 0,-1]
		</th>
		<th>
			[ 1, 0, 0]<br/>
			[ 0, 0, 1]<br/>
			[ 0,-1, 0]
		</th>
		<th>
			[ 0, 0,-1]<br/>
			[ 0, 1, 0]<br/>
			[ 1, 0, 0]
		</th>
		<th>
			[-1, 0, 0]<br/>
			[ 0, 1, 0]<br/>
			[ 0, 0,-1]
		</th>
	</tr>
	<tr>
		<th>
			[ 0, 0, 1]<br/>
			[ 0, 1, 0]<br/>
			[-1, 0, 0]
		</th>
		<th>
			[ 0,-1, 0]<br/>
			[ 1, 0, 0]<br/>
			[ 0, 0, 1]
		</th>
		<th>
			[-1, 0, 0]<br/>
			[ 0,-1, 0]<br/>
			[ 0, 0, 1]
		</th>
		<th>
			[ 0, 1, 0]<br/>
			[-1, 0, 0]<br/>
			[ 0, 0, 1]
		</th>
		<th>
			[-1, 0, 0]<br/>
			[ 0, 0, 1]<br/>
			[ 0, 1, 0]
		</th>
		<th>
			[-1, 0, 0]<br/>
			[ 0, 0,-1]<br/>
			[ 0,-1, 0]
		</th>
	</tr>
	<tr>
		<th>
			[ 0, 0, 1]<br/>
			[ 0,-1, 0]<br/>
			[ 1, 0, 0]
		</th>
		<th>
			[ 0, 0,-1]<br/>
			[ 0,-1, 0]<br/>
			[-1, 0, 0]
		</th>
		<th>
			[ 0, 1, 0]<br/>
			[ 1, 0, 0]<br/>
			[ 0, 0,-1]
		</th>
		<th>
			[ 0,-1, 0]<br/>
			[-1, 0, 0]<br/>
			[ 0, 0,-1]
		</th>
		<th>
			[ 0, 0, 1]<br/>
			[ 1, 0, 0]<br/>
			[ 0, 1, 0]
		</th>
		<th>
			[ 0, 1, 0]<br/>
			[ 0, 0, 1]<br/>
			[ 1, 0, 0]
		</th>
	</tr>
	<tr>
		<th>
			[ 0, 0,-1]<br/>
			[-1, 0, 0]<br/>
			[ 0, 1, 0]
		</th>
		<th>
			[ 0,-1, 0]<br/>
			[ 0, 0, 1]<br/>
			[-1, 0, 0]
		</th>
		<th>
			[ 0, 0, 1]<br/>
			[-1, 0, 0]<br/>
			[ 0,-1, 0]
		</th>
		<th>
			[ 0,-1, 0]<br/>
			[ 0, 0,-1]<br/>
			[ 1, 0, 0]
		</th>
		<th>
			[ 0, 0,-1]<br/>
			[ 1, 0, 0]<br/>
			[ 0,-1, 0]
		</th>
		<th>
			[ 0, 1, 0]<br/>
			[ 0, 0,-1]<br/>
			[-1, 0, 0]
		</th>
	</tr>
</table>
<p style="text-indent:40px;">So for instance, to rotate around one corner of the cube, we could multiply that rotation matrix by the list of colume vectors representing the corners of the cube:</p>

<table id="configsTable" style="width:500px;margin-left:80px;text-align:center;">
	<tr>
		<th>
			[ 0, 0,-1] [ 1, 1, 1, 1,-1,-1,-1,-1] [-1, 1,-1, 1,-1, 1,-1, 1]<br/>
			[ 1, 0, 0]*[ 1, 1,-1,-1, 1, 1,-1,-1]=[ 1, 1, 1, 1,-1,-1,-1,-1]<br/>
			[ 0,-1, 0] [ 1,-1, 1,-1, 1,-1, 1,-1] [-1,-1, 1, 1,-1,-1, 1, 1]
		</th>
	</tr>
</table>
<!-- TODO: list of rotation matrices along with interactive tool to apply them to a cube -->
<p style="text-indent:40px;"></p>
<h1>Connected colorings (in progress)</h1>
<p style="text-indent:40px;">In general, it is to be expected that finding the number of connected colorings of a graph (a collection of nodes connected by edges) will be computationally expensive, approaching the cost of simply checking every possible coloring. </p>
<p style="text-indent:40px;">The <a href="https://cstheory.stackexchange.com/questions/3465/complexity-of-counting-all-connected-subgraphs">connected subgraph counting problem</a> is in <a href="https://en.wikipedia.org/wiki/%E2%99%AFP">the complexity class #P</a> which is related to and harder than <a href="https://en.wikipedia.org/wiki/NP_(complexity)">the complexity class NP</a>.</p>
<p style="text-indent:40px;">The square edge graph has properties that make it much more efficient to work with. It is small, symmetric, and sparse. The following analysis will rely on these special properties.</p>
<p style="text-indent:40px;">We can begin by splitting the cube up into three sections, the bottom face, top face, and connecting vertical bridges, and splitting up the analysis by how many of these bridge edges are colored.</p>
<p style="text-indent:40px;">There will be no consideration of rotational equivalence in this section, so two colorings of the cube that are rotationally equivalent will be considered distinct for the purpose of counting. However, rotational symmetry will be used extensively to speed up the counting process.</p>
<h2>One square face</h2>
<p style="text-indent:40px;">The edges of a square can be colored 1 way with no edges, 2 ways with 2 disconnected edges, and 13 ways with connected edges.</p>
<svg id="svg_square" height="0" width="0" xmlns="http://www.w3.org/2000/svg">
<h2>Cube with 0 bridges</h2>
<p style="text-indent:40px;">Suppose that none of the bridges are colored in. In that case, the top and bottom faces are independent of each other and cannot be connected. </p>
<p style="text-indent:40px;">The edges of a square can be colored 1 way with no edges, 2 ways with 2 disconnected edges, and 13 ways with connected edges.</p>
<p style="text-indent:40px;">We can combine these numbers by adding the number of connected components, and multiplying the number of independent colorings on the top and bottom faces.</p>
<table id="configsTable" style="width:600px;margin-left:80px;text-align:center;">
	<tr><th>        </th><th>0 CC:  1</th><th>1 CC:  13</th><th>2 CC:  2</th></tr>
	<tr><th>0 CC:  1</th><td>0 CC:  1</td><td>1 CC:  13</td><td>2 CC:  2</td></tr>
	<tr><th>1 CC: 13</th><td>1 CC: 13</td><td>2 CC: 169</td><td>3 CC: 26</td></tr>
	<tr><th>2 CC:  2</th><td>2 CC:  2</td><td>3 CC:  26</td><td>4 CC:  4</td></tr>
</table>
<p style="text-indent:40px;">For the whole cube with no bridges there are this many colorings of each type:</p>
<p style="text-indent:80px;"><tt>0 CC: 1</tt></p>
<p style="text-indent:80px;"><tt>1 CC: 26</tt></p>
<p style="text-indent:80px;"><tt>2 CC: 173</tt></p>
<p style="text-indent:80px;"><tt>3 CC: 52</tt></p>
<p style="text-indent:80px;"><tt>4 CC: 4</tt></p>
<h2>Cube with 1 bridge</h2>
<p style="text-indent:40px;">Suppose that one of the bridges is colored in. There are four ways to do this, and the number of colorings in each case will be the same, so we can multiply any number we get in this section by 4 at the end. </p>
<p style="text-indent:40px;">Because there is one edge that is already colored, there will be at least one connected component, and whether or not there is more than one will depend on whether other edges are connected to this one.</p>
<p style="text-indent:40px;">Because three of the bridges are not colored in, the top and bottom faces are almost independent of one another.</p>
<p style="text-indent:40px;">The independent cases to be distinguished are how many connected components there are on a face that do not touch the bridge.</p>
<svg id="svg_1_bridge" height="0" width="0" xmlns="http://www.w3.org/2000/svg">
<p style="text-indent:40px;">We can combine these numbers by adding the number of connected components, minus one for the duplicated bridge component, and multiplying the number of independent colorings on the top and bottom faces.</p>
<table id="configsTable" style="width:600px;margin-left:80px;text-align:center;">
	<tr><th>        </th><th>1 CC: 11</th><th>2 CC:  5</th></tr>
	<tr><th>1 CC: 11</th><td>1 CC:121</td><td>2 CC: 55</td></tr>
	<tr><th>2 CC:  5</th><td>2 CC: 55</td><td>3 CC: 25</td></tr>
</table>
<p style="text-indent:40px;">For the whole cube with one colored bridge there are this many colorings of each type:</p>
<p style="text-indent:80px;"><tt>1 CC: 121</tt></p>
<p style="text-indent:80px;"><tt>2 CC: 110</tt></p>
<p style="text-indent:80px;"><tt>3 CC: 25</tt></p>
<h2>Cube with 2 adjacent bridges</h2>
<p style="text-indent:40px;">Suppose that two of the bridges are colored in, and they are on the same side. There are four ways to do this, and the number of colorings in each case will be the same, so we can multiply any number we get in this section by 4 at the end. </p>
<p style="text-indent:40px;">Because there are two edges already colored in, there will be at least one connected component, and whether there are two or more will depend on how these are connected.</p>
<p style="text-indent:40px;">The independent cases to be distinguished on each face are whether these two bridges get connected, and whether or not the</p>
<p style="text-indent:40px;">The independent cases to be distinguished are how many connected components there are on a face that do not touch the bridge.</p>
<svg id="svg_2_adj_bridge" height="0" width="0" xmlns="http://www.w3.org/2000/svg">
<p style="text-indent:40px;">We can combine these numbers by adding the number of connected components, minus one if the bridges are connected on both faces or two if they are not, and multiplying the number of independent colorings on the top and bottom faces.</p>
<table id="configsTable" style="width:600px;margin-left:80px;text-align:center;">
	<tr><th>          </th><th>BD 2 CC:  6</th><th>BD 3 CC: 1</th><th>BC 1 CC:  8</th><th>BC 2 CC: 1</th></tr>
	<tr><th>BD 2 CC: 6</th><td>   2 CC: 36</td><td>   3 CC: 6</td><td>   1 CC: 48</td><td>   2 CC: 6</td></tr>
	<tr><th>BD 3 CC: 1</th><td>   3 CC:  6</td><td>   4 CC: 1</td><td>   2 CC:  8</td><td>   3 CC: 1</td></tr>
	<tr><th>BC 1 CC: 8</th><td>   1 CC: 48</td><td>   2 CC: 8</td><td>   1 CC: 64</td><td>   2 CC: 8</td></tr>
	<tr><th>BC 2 CC: 1</th><td>   2 CC:  6</td><td>   3 CC: 1</td><td>   2 CC:  8</td><td>   3 CC: 1</td></tr>
</table>
<p style="text-indent:40px;">For the whole cube with two adjacent colored bridges there are this many colorings of each type:</p>
<p style="text-indent:80px;"><tt>1 CC: 160</tt></p>
<p style="text-indent:80px;"><tt>2 CC: 80</tt></p>
<p style="text-indent:80px;"><tt>3 CC: 15</tt></p>
<p style="text-indent:80px;"><tt>4 CC: 1</tt></p>
<h2>Cube with 2 antipodal bridges</h2>
<p style="text-indent:40px;">Suppose that two of the bridges are colored in, and they are on opposite ends of the cube. There are two ways to do this, and the number of colorings in each case will be the same, so we can multiply any number we get in this section by 2 at the end. </p>
<p style="text-indent:40px;">In this case, every edge on the top and bottom faces touches one of the already colored bridges, so there cannot be more than 2 connected components.</p>
<p style="text-indent:40px;">Whether there are 2 or 1 connected components is determined by whether these two bridges are connected in any way at all. </p>
<svg id="svg_2_anti_bridge" height="0" width="0" xmlns="http://www.w3.org/2000/svg">
<p style="text-indent:40px;">We can combine these numbers by taking the lesser of the number of connected components, and multiplying the number of independent colorings on the top and bottom faces.</p>
<table id="configsTable" style="width:600px;margin-left:80px;text-align:center;">
	<tr><th>       </th><th>1 CC:  7</th><th>2 CC:  9</th></tr>
	<tr><th>1 CC: 7</th><td>1 CC: 49</td><td>1 CC: 63</td></tr>
	<tr><th>2 CC: 9</th><td>1 CC: 63</td><td>2 CC: 81</td></tr>
</table>
<p style="text-indent:40px;">For the whole cube with two antipodal colored bridges there are this many colorings of each type:</p>
<p style="text-indent:80px;"><tt>1 CC: 175</tt></p>
<p style="text-indent:80px;"><tt>2 CC: 81</tt></p>
<h2>Cube with 3 bridges</h2>
<h2>Cube with 4 bridges</h2>


<p style="text-indent:40px;"></p>
<p style="text-indent:80px;"><tt></tt></p>

</body>
<script>


// TODO: list out rotation matrices (done)
// TODO: create cube data structure
// TODO: function to apply rotation matrix to cube
// TODO: function to compare cubes
// TODO: function to loop over possible cubes and compare them
// TODO: list of unique cubes
// TODO: display cube in simplified form in svg (done)
// TODO: display array of cubes in simplified form in svg
// TODO: filter cubes to remove disconnected, empty, full, 2D cases
// TODO: verify each rotation matrix by applying it to its axis vector and checking that there is no change
// TODO: create a loop that counts a numeric variable up but then interprets each bit as a flag for each edge in a cube


rotIdentity = 
 [[ 1, 0, 0],
  [ 0, 1, 0],
  [ 0, 0, 1]]
rotX90 = 
 [[ 1, 0, 0],
  [ 0, 0,-1],
  [ 0, 1, 0]]
rotX180 = 
 [[ 1, 0, 0],
  [ 0,-1, 0],
  [ 0, 0,-1]]
rotX270 = 
 [[ 1, 0, 0],
  [ 0, 0, 1],
  [ 0,-1, 0]]
rotY90 = 
 [[ 0, 0,-1],
  [ 0, 1, 0],
  [ 1, 0, 0]]
rotY180 = 
 [[-1, 0, 0],
  [ 0, 1, 0],
  [ 0, 0,-1]]
rotY270 = 
 [[ 0, 0, 1],
  [ 0, 1, 0],
  [-1, 0, 0]]
rotZ90 = 
 [[ 0,-1, 0],
  [ 1, 0, 0],
  [ 0, 0, 1]]
rotZ180 = 
 [[-1, 0, 0],
  [ 0,-1, 0],
  [ 0, 0, 1]]
rotZ270 = 
 [[ 0, 1, 0],
  [-1, 0, 0],
  [ 0, 0, 1]]
rotEdgeXPos = 
 [[-1, 0, 0],
  [ 0, 0, 1],
  [ 0, 1, 0]]
rotEdgeXNeg = 
 [[-1, 0, 0],
  [ 0, 0,-1],
  [ 0,-1, 0]]
rotEdgeYPos = 
 [[ 0, 0, 1],
  [ 0,-1, 0],
  [ 1, 0, 0]]
rotEdgeYNeg = 
 [[ 0, 0,-1],
  [ 0,-1, 0],
  [-1, 0, 0]]
rotEdgeZPos = 
 [[ 0, 1, 0],
  [ 1, 0, 0],
  [ 0, 0,-1]]
rotEdgeZNeg = 
 [[ 0,-1, 0],
  [-1, 0, 0],
  [ 0, 0,-1]]
rotCornerXYZ120 = 
 [[ 0, 0, 1],
  [ 1, 0, 0],
  [ 0, 1, 0]]
rotCornerXYZ240 = 
 [[ 0, 1, 0],
  [ 0, 0, 1],
  [ 1, 0, 0]]
rotCornerX120 = 
 [[ 0, 0,-1],
  [-1, 0, 0],
  [ 0, 1, 0]]
rotCornerX240 = 
 [[ 0,-1, 0],
  [ 0, 0, 1],
  [-1, 0, 0]]
rotCornerY120 = 
 [[ 0, 0, 1],
  [-1, 0, 0],
  [ 0,-1, 0]]
rotCornerY240 = 
 [[ 0,-1, 0],
  [ 0, 0,-1],
  [ 1, 0, 0]]
rotCornerZ120 = 
 [[ 0, 0,-1],
  [ 1, 0, 0],
  [ 0,-1, 0]]
rotCornerZ240 = 
 [[ 0, 1, 0],
  [ 0, 0,-1],
  [-1, 0, 0]]

rotations = 
 [rotIdentity,
  rotX90,
  rotX180,
  rotX270,
  rotY90,
  rotY180,
  rotY270,
  rotZ90,
  rotZ180,
  rotZ270,
  rotEdgeXPos,
  rotEdgeXNeg,
  rotEdgeYPos,
  rotEdgeYNeg,
  rotEdgeZPos,
  rotEdgeZNeg,
  rotCornerXYZ120,
  rotCornerXYZ240,
  rotCornerX120,
  rotCornerX240,
  rotCornerY120,
  rotCornerY240,
  rotCornerZ120,
  rotCornerZ240]

completeCube = 
 [[[0,1,0],
   [1,0,1],
   [0,1,0]],
  [[1,0,1],
   [0,0,0],
   [1,0,1]],
  [[0,1,0],
   [1,0,1],
   [0,1,0]]]

cubeEdgeCoordinates = 
 [[0,0,1],
  [0,1,0],
  [0,1,2],
  [0,2,1],
  [1,0,0],
  [1,0,2],
  [1,2,0],
  [1,2,2],
  [2,0,1],
  [2,1,0],
  [2,1,2],
  [2,2,1]]

cubeEdgeCoordinates2 = 
 [[ 6,[-1,-1, 0]],
  [ 5,[-1, 0,-1]],
  [12,[-1, 0, 1]],
  [10,[-1, 1, 0]],
  [11,[ 0,-1,-1]],
  [ 1,[ 0,-1, 1]],
  [ 4,[ 0, 1,-1]],
  [ 8,[ 0, 1, 1]],
  [ 7,[ 1,-1, 0]],
  [ 9,[ 1, 0,-1]],
  [ 2,[ 1, 0, 1]],
  [ 3,[ 1, 1, 0]]]

cubeEdgeIndices = 
 [[[ 0, 0, 0],
   [ 1, 0, 2],
   [ 0, 3, 0]],
  [[ 4, 0, 5],
   [ 0, 0, 0],
   [ 6, 0, 7]],
  [[ 0, 8, 0],
   [ 9, 0,10],
   [ 0,11, 0]]]

neighborIndices =
 [[1,2,4,5],
  [0,3,4,6],
  [0,3,5,7],
  [1,2,6,7],
  [0,1,8,9],
  [0,2,8,10],
  [1,3,9,11],
  [2,3,10,11],
  [4,5,9,10],
  [4,6,8,11],
  [5,7,8,11],
  [6,7,9,10]]

function cubeEdgeToIndex(edge) {
	let newEdge = cubeEdgeIndices[edge[0]+1][edge[1]+1][edge[2]+1];
	return newEdge
}

function cubeIndexToEdge(index) {
	return cubeEdgeCoordinates2[index][1];
}

function applyRotationToEdge(matrix,edge) {
	let newEdge = [0,0,0];
	for(let r=0; r<3; r++) {
		let tmp = 0;
		for(let c=0; c<3; c++) {
			tmp += matrix[r][c]*edge[c];
		}
		newEdge[r] = tmp;
	}
	return newEdge;
}

function applyRotationToIndex(matrix,index) {
	let edge = cubeIndexToEdge(index);
	let newEdge = applyRotationToEdge(matrix,edge);
	let newIndex = cubeEdgeToIndex(newEdge);
	return newIndex;
}

function cubeToIndices(cube) {
	let indices = [0,0,0,0,0,0,0,0,0,0,0,0];
	for(let k=0; k<12; k++) {
		let bit = (cube>>k)&1;
		if(bit==1) {
			indices[k] = 1;
		}
	}
	return indices;
}

function indicesToCube(indices) {
	let cube = 0;
	for(let k=0; k<12; k++) {
		let bit = indices[k];
		cube = cube|(bit<<k);
	}
	return cube;
}

function rotateCube(matrix,cube) {
	let indices = cubeToIndices(cube);
	let newIndices = [0,0,0,0,0,0,0,0,0,0,0,0];
	for(let k=0; k<12; k++) {
		let bit = indices[k];
		if(bit) {
			let newIndex = applyRotationToIndex(matrix,k);
			newIndices[newIndex] = 1;
		}
	}
	let newCube = indicesToCube(newIndices);
	return newCube;
}

function displayCube(bits) {
	for(let k=0; k<12; k++) {
		let edgeId = cubeEdgeCoordinates2[k][0];
		let bit = (bits>>k)&1;
		if(bit==1) {
			document.getElementById("e"+edgeId).style.opacity = "1";
		} else {
			document.getElementById("e"+edgeId).style.opacity = "0";
		}
	}
}

function displayRandomCube() {
	displayCube(Math.floor(Math.random()*4096));
}

//displayRandomCube();
//displayCube(rotateCube(rotations[23],14));

let distinctCubes = [];

function iterateOverCubes() {
	for(let bits=0; bits<4096; bits++) {
		let duplicate = 0;
		for(let rotationIndex=0; rotationIndex<24; rotationIndex++) {
			rotation = rotations[rotationIndex];
			let newBits = rotateCube(rotation,bits);
			if(distinctCubes.includes(newBits)) {
				duplicate = 1;
				continue;
			}
		}
		if(duplicate==0) {
			distinctCubes.push(bits);
		}
	}
	console.log(distinctCubes.length);
}

iterateOverCubes();

//displayCube(distinctCubes[175]);

function cubePointToScreenPointAsHexagon(x,y,z,xmax) {
	// 0,0,0 on the cube maps to 0,0 on the screen
	// -1,1,1 and 1,-1,-1 on the cube map to 0,0 on the screen
	// screen points will be within ([-xmax,xmax],[-xmax,xmax]) bounding box
	let r3 = 1.732;
	let screenPoint = [0,0];
	screenPoint[0] = Math.round((0.5*x+0.25*y+0.25*z)*xmax);
	screenPoint[1] = Math.round((0.0*x+0.25*r3*y-0.25*r3*z)*xmax);
	return screenPoint;
}

function cubePointToScreenPointAsSquare(x,y,z,xmax) {
	// 0,0,0 on the cube maps to 0,0 on the screen
	// 0,0,1 and 0,0,-1 on the cube map to 0,0 on the screen
	// screen points will be within ([-xmax,xmax],[-xmax,xmax]) bounding box
	let screenPoint = [0,0];
	screenPoint[0] = Math.round(x*(0.66+0.33*z)*xmax);
	screenPoint[1] = Math.round(y*(0.66+0.33*z)*xmax);
	return screenPoint;
}

function paintCorner(svg,x,y,z,offsetX,offsetY,size) {
	//let screenPoint = cubePointToScreenPointAsHexagon(x,y,z,size);
	let screenPoint = cubePointToScreenPointAsSquare(x,y,z,size);
	let circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
	svg.appendChild(circle);
	//circle.setAttribute("r","2");
	circle.setAttribute("r","1");
	circle.setAttribute("cx",""+(screenPoint[0]+offsetX));
	circle.setAttribute("cy",""+(screenPoint[1]+offsetY));
	circle.setAttribute("fill","black");
}

function paintEdge(svg, edge, offsetX, offsetY, size) {
	let x1 = edge[0]==0?-1:edge[0];
	let y1 = edge[1]==0?-1:edge[1];
	let z1 = edge[2]==0?-1:edge[2];
	let x2 = edge[0]==0?1:edge[0];
	let y2 = edge[1]==0?1:edge[1];
	let z2 = edge[2]==0?1:edge[2];
	//let screenPoint1 = cubePointToScreenPointAsHexagon(x1,y1,z1,size);
	//let screenPoint2 = cubePointToScreenPointAsHexagon(x2,y2,z2,size);
	let screenPoint1 = cubePointToScreenPointAsSquare(x1,y1,z1,size);
	let screenPoint2 = cubePointToScreenPointAsSquare(x2,y2,z2,size);
	let polygon = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
	svg.appendChild(polygon);
	polygon.setAttribute("style", "fill:black;stroke:black;stroke-width:1");
	let point1 = svg.createSVGPoint();
	point1.x = screenPoint1[0]+offsetX;
	point1.y = screenPoint1[1]+offsetY;
	polygon.points.appendItem(point1);
	let point2 = svg.createSVGPoint();
	point2.x = screenPoint2[0]+offsetX;
	point2.y = screenPoint2[1]+offsetY;
	polygon.points.appendItem(point2);
}

function paintSquare(svg, left, top, right, bottom, offsetX, offsetY, size) {
	if(left) {
		paintEdge(svg,[-1,0,1],offsetX,offsetY,size);
	}
	if(right) {
		paintEdge(svg,[1,0,1],offsetX,offsetY,size);
	}
	if(top) {
		paintEdge(svg,[0,-1,1],offsetX,offsetY,size);
	}
	if(bottom) {
		paintEdge(svg,[0,1,1],offsetX,offsetY,size);
	}
	for(let x=-1; x<=1; x+=2) {
		for(let y=-1; y<=1; y+=2) {
			paintCorner(svg,x,y,1,offsetX,offsetY,size);
		}
	}
}
function paintCube(svg, cube, offsetX, offsetY, size) {
	let indices = cubeToIndices(cube);
	for(let k=0; k<12; k++) {
		let bit = indices[k];
		if(bit) {
			let edge = cubeEdgeCoordinates2[k][1];
			paintEdge(svg,edge,offsetX,offsetY,size);
		}
	}
	for(let x=-1; x<=1; x+=2) {
		for(let y=-1; y<=1; y+=2) {
			for(let z=-1; z<=1; z+=2) {
				paintCorner(svg,x,y,z,offsetX,offsetY,size);
			}
		}
	}
}

function paintAllDistinctCubes(svg) {
	for(let c=0; c<15; c++) {
		for(let r=0; r<15; r++) {
			if(c*15+r>=distinctCubes.length) break;
			paintCube(svg,distinctCubes[c*15+r],r*40+20,c*40+20,10);
		}
	}
}

//paintAllDistinctCubes()

function countNumberOfEdges(bits) {
	let indices = cubeToIndices(bits);
	let numberOfEdges = 0;
	for(let k=0; k<12; k++) {
		if(indices[k]==1) {
			numberOfEdges++;
		}
	}
	return numberOfEdges;
}

function countNumberOfConnectedComponents(bits) {
	let indices = cubeToIndices(bits);
	let visited = [0,0,0,0,0,0,0,0,0,0,0,0];
	let numberOfConnectedComponents = 0;
	while(true) {
		let finished = 1;
		for(let k=0; k<12; k++) {
			if(indices[k]==1&&visited[k]==0) {
				finished = 0;
				numberOfConnectedComponents++;
				visited[k] = 1;
				break;
			}
		}
		if(finished==1) break;
		while(true) {
			let componentFinished = 1;
			for(let k=0; k<12; k++) {
				if(indices[k]==0) continue;
				if(visited[k]==1) {
					visited[k] = 2;
					componentFinished = 0;
					let neighbors = neighborIndices[k];
					for(let n=0; n<neighbors.length; n++) {
						let neighbor = neighbors[n];
						if(indices[neighbor]==0) continue;
						if(visited[neighbor]==0) {
							visited[neighbor] = 1;
						}
					}
				}
			}
			if(componentFinished==1) break;
		}
	}
	return numberOfConnectedComponents;
}

// stratified by number of connected components and then number of edges
let stratifiedCubes = 
 [[[],[],[],[],[],[],[],[],[],[],[],[],[]],
  [[],[],[],[],[],[],[],[],[],[],[],[],[]],
  [[],[],[],[],[],[],[],[],[],[],[],[],[]],
  [[],[],[],[],[],[],[],[],[],[],[],[],[]],
  [[],[],[],[],[],[],[],[],[],[],[],[],[]]]

function stratifyDistinctCubes() {
	for(let k=0; k<distinctCubes.length; k++) {
		let bits = distinctCubes[k];
		let numberOfEdges = countNumberOfEdges(bits);
		let numberOfConnectedComponents = countNumberOfConnectedComponents(bits);
		stratifiedCubes[numberOfConnectedComponents][numberOfEdges].push(bits);
	}
}

stratifyDistinctCubes();

console.log(stratifiedCubes);


function paintLine(svg,p1,p2) {
	let line = document.createElementNS("http://www.w3.org/2000/svg", "line");
	line.setAttribute("style", "stroke:black;stroke-width:1");
	svg.appendChild(line);
	line.setAttribute("x1",p1[0]);
	line.setAttribute("y1",p1[1]);
	line.setAttribute("x2",p2[0]);
	line.setAttribute("y2",p2[1]);
}

function paintText(svg,x,y,textContent) {
	let text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
	text.setAttribute('x',x);
	text.setAttribute('y',y);
	text.setAttribute('fill','#000');
	text.setAttribute("style","font-size:20px;");
	text.textContent = textContent;
	svg.appendChild(text); 
}

function paintFrame(svg,width,height) {
	paintLine(svg,[0,0],[width,0]);
	paintLine(svg,[width,0],[width,height]);
	paintLine(svg,[width,height],[0,height]);
	paintLine(svg,[0,height],[0,0]);
}

function paintAllDistinctStratifiedCubes(svg,svgh,numberOfEdges) {
	// TODO: swap r and c for readability?
	let r = -1;
	let c = -2;
	let numberOfCubes = 0;
	for(let numberOfConnectedComponents=0; numberOfConnectedComponents<5; numberOfConnectedComponents++) {
		let cubes = stratifiedCubes[numberOfConnectedComponents][numberOfEdges];
		if(cubes.length>0) {
			c += 2;
			r = -1;
			let componentsText = numberOfConnectedComponents==1?" Connected component":" Connected components";
			paintText(svg,10,c*40+30,numberOfConnectedComponents+componentsText+" ("+cubes.length+" cube"+(cubes.length==1?"":"s")+")");
			for(let k=0; k<cubes.length; k++) {
				r++;
				if(r==15) {
					r = 0;
					c++;
				}
				paintCube(svg,cubes[k],r*40+20,(c+1)*40+20,10);
				numberOfCubes++;
			}
		}
	}
	let h = (c+2)*40+10;
	svg.setAttribute('width','800');
	svg.setAttribute('height',h);
	paintFrame(svg,800,h);
	svgh.innerText = "Rotationally distinct cubes with "+numberOfEdges+" edge"+(numberOfEdges==1?"":"s")+" ("+numberOfCubes+" cube"+(numberOfCubes==1?"":"s")+")";
}

// TODO: this is working even though svg0 etc are not declared variables, how standard is that across browsers?
paintAllDistinctStratifiedCubes(svg0,svgh0,0);
paintAllDistinctStratifiedCubes(svg1,svgh1,1);
paintAllDistinctStratifiedCubes(svg2,svgh2,2);
paintAllDistinctStratifiedCubes(svg3,svgh3,3);
paintAllDistinctStratifiedCubes(svg4,svgh4,4);
paintAllDistinctStratifiedCubes(svg5,svgh5,5);
paintAllDistinctStratifiedCubes(svg6,svgh6,6);
paintAllDistinctStratifiedCubes(svg7,svgh7,7);
paintAllDistinctStratifiedCubes(svg8,svgh8,8);
paintAllDistinctStratifiedCubes(svg9,svgh9,9);
paintAllDistinctStratifiedCubes(svg10,svgh10,10);
paintAllDistinctStratifiedCubes(svg11,svgh11,11);
paintAllDistinctStratifiedCubes(svg12,svgh12,12);

function paintAllDistinctStratifiedSquares(svg) {
	paintText(svg,10,30,"0 Connected components (1 square)");
	paintSquare(svg,false,false,false,false,30,60,10);
	paintText(svg,10,110,"1 Connected components (13 squares)");
	paintSquare(svg,true,false,false,false,30,140,10);
	paintSquare(svg,false,true,false,false,70,140,10);
	paintSquare(svg,false,false,true,false,110,140,10);
	paintSquare(svg,false,false,false,true,150,140,10);
	paintSquare(svg,true,true,false,false,190,140,10);
	paintSquare(svg,false,true,true,false,230,140,10);
	paintSquare(svg,false,false,true,true,270,140,10);
	paintSquare(svg,true,false,false,true,310,140,10);
	paintSquare(svg,true,true,true,false,350,140,10);
	paintSquare(svg,false,true,true,true,390,140,10);
	paintSquare(svg,true,false,true,true,430,140,10);
	paintSquare(svg,true,true,false,true,470,140,10);
	paintSquare(svg,true,true,true,true,510,140,10);
	paintText(svg,10,190,"2 Connected components (2 squares)");
	paintSquare(svg,true,false,true,false,30,220,10);
	paintSquare(svg,false,true,false,true,70,220,10);
	svg.setAttribute('width','800');
	svg.setAttribute('height','250');
	paintFrame(svg,800,250);
}
// TODO: indent to match other content
paintAllDistinctStratifiedSquares(svg_square);

function paintOneBridgeCubes(svg) {
	paintText(svg,10,30,"1 Connected component (11 squares)");
	paintCube(svg,indicesToCube([1,0,0,0,0,0,0,0,0,0,0,0]),30,60,10);
	paintCube(svg,indicesToCube([1,0,0,0,0,1,0,0,0,0,0,0]),70,60,10);
	paintCube(svg,indicesToCube([1,0,1,0,0,0,0,0,0,0,0,0]),110,60,10);
	paintCube(svg,indicesToCube([1,0,0,0,0,1,0,0,0,0,1,0]),150,60,10);
	paintCube(svg,indicesToCube([1,0,1,0,0,1,0,0,0,0,0,0]),190,60,10);
	paintCube(svg,indicesToCube([1,0,1,0,0,0,0,1,0,0,0,0]),230,60,10);
	paintCube(svg,indicesToCube([1,0,0,0,0,1,0,1,0,0,1,0]),270,60,10);
	paintCube(svg,indicesToCube([1,0,1,0,0,1,0,1,0,0,0,0]),310,60,10);
	paintCube(svg,indicesToCube([1,0,1,0,0,1,0,0,0,0,1,0]),350,60,10);
	paintCube(svg,indicesToCube([1,0,1,0,0,0,0,1,0,0,1,0]),390,60,10);
	paintCube(svg,indicesToCube([1,0,1,0,0,1,0,1,0,0,1,0]),430,60,10);
	paintText(svg,10,110,"2 Connected components (5 squares)");
	paintCube(svg,indicesToCube([1,0,0,0,0,0,0,1,0,0,0,0]),30,140,10);
	paintCube(svg,indicesToCube([1,0,0,0,0,0,0,0,0,0,1,0]),70,140,10);
	paintCube(svg,indicesToCube([1,0,0,0,0,0,0,1,0,0,1,0]),110,140,10);
	paintCube(svg,indicesToCube([1,0,1,0,0,0,0,0,0,0,1,0]),150,140,10);
	paintCube(svg,indicesToCube([1,0,0,0,0,1,0,1,0,0,0,0]),190,140,10);
	svg.setAttribute('width','800');
	svg.setAttribute('height','170');
	paintFrame(svg,800,170);
}
// TODO: indent to match other content
paintOneBridgeCubes(svg_1_bridge);

function paintTwoAdjBridgeCubes(svg) {
	paintText(svg,10,30,"Bridges disconnected + 2 Connected components (6 squares)");
	paintCube(svg,indicesToCube([1,0,0,0,0,0,0,0,1,0,0,0]),30,60,10);
	paintCube(svg,indicesToCube([1,0,0,0,0,0,0,0,1,0,1,0]),70,60,10);
	paintCube(svg,indicesToCube([1,0,0,0,0,0,0,1,1,0,1,0]),110,60,10);
	paintCube(svg,indicesToCube([1,0,1,0,0,0,0,0,1,0,1,0]),150,60,10);
	paintCube(svg,indicesToCube([1,0,1,0,0,0,0,0,1,0,0,0]),190,60,10);
	paintCube(svg,indicesToCube([1,0,1,0,0,0,0,1,1,0,0,0]),230,60,10);
	paintText(svg,10,110,"Bridges disconnected + 3 Connected components (1 square)");
	paintCube(svg,indicesToCube([1,0,0,0,0,0,0,1,1,0,0,0]),30,140,10);
	paintText(svg,10,190,"Bridges connected + 1 Connected component (8 squares)");
	paintCube(svg,indicesToCube([1,0,0,0,0,1,0,0,1,0,0,0]),30,220,10);
	paintCube(svg,indicesToCube([1,0,0,0,0,1,0,0,1,0,1,0]),70,220,10);
	paintCube(svg,indicesToCube([1,0,1,0,0,1,0,0,1,0,0,0]),110,220,10);
	paintCube(svg,indicesToCube([1,0,0,0,0,1,0,1,1,0,1,0]),150,220,10);
	paintCube(svg,indicesToCube([1,0,1,0,0,1,0,1,1,0,0,0]),190,220,10);
	paintCube(svg,indicesToCube([1,0,1,0,0,1,0,0,1,0,1,0]),230,220,10);
	paintCube(svg,indicesToCube([1,0,1,0,0,0,0,1,1,0,1,0]),270,220,10);
	paintCube(svg,indicesToCube([1,0,1,0,0,1,0,1,1,0,1,0]),310,220,10);
	paintText(svg,10,270,"Bridges connected + 2 Connected components (1 square)");
	paintCube(svg,indicesToCube([1,0,0,0,0,1,0,1,1,0,0,0]),30,300,10);
	svg.setAttribute('width','800');
	svg.setAttribute('height','330');
	paintFrame(svg,800,330);
}
// TODO: indent to match other content
paintTwoAdjBridgeCubes(svg_2_adj_bridge);

function paintTwoAntiBridgeCubes(svg) {
	paintText(svg,10,30,"1 Connected component (7 squares)");
	paintCube(svg,indicesToCube([1,0,1,0,0,0,0,1,0,0,0,1]),30,60,10);
	paintCube(svg,indicesToCube([1,0,0,0,0,1,0,0,0,0,1,1]),70,60,10);
	paintCube(svg,indicesToCube([1,0,0,0,0,1,0,1,0,0,1,1]),110,60,10);
	paintCube(svg,indicesToCube([1,0,1,0,0,1,0,1,0,0,0,1]),150,60,10);
	paintCube(svg,indicesToCube([1,0,1,0,0,1,0,0,0,0,1,1]),190,60,10);
	paintCube(svg,indicesToCube([1,0,1,0,0,0,0,1,0,0,1,1]),230,60,10);
	paintCube(svg,indicesToCube([1,0,1,0,0,1,0,1,0,0,1,1]),270,60,10);
	paintText(svg,10,110,"2 Connected components (9 squares)");
	paintCube(svg,indicesToCube([1,0,0,0,0,0,0,0,0,0,0,1]),30,140,10);
	paintCube(svg,indicesToCube([1,0,0,0,0,0,0,0,0,0,1,1]),70,140,10);
	paintCube(svg,indicesToCube([1,0,1,0,0,0,0,0,0,0,0,1]),110,140,10);
	paintCube(svg,indicesToCube([1,0,0,0,0,0,0,1,0,0,0,1]),150,140,10);
	paintCube(svg,indicesToCube([1,0,0,0,0,1,0,0,0,0,0,1]),190,140,10);
	paintCube(svg,indicesToCube([1,0,0,0,0,0,0,1,0,0,1,1]),230,140,10);
	paintCube(svg,indicesToCube([1,0,1,0,0,0,0,0,0,0,1,1]),270,140,10);
	paintCube(svg,indicesToCube([1,0,1,0,0,1,0,0,0,0,0,1]),310,140,10);
	paintCube(svg,indicesToCube([1,0,0,0,0,1,0,1,0,0,0,1]),350,140,10);
	svg.setAttribute('width','800');
	svg.setAttribute('height','170');
	paintFrame(svg,800,170);
}
// TODO: indent to match other content
paintTwoAntiBridgeCubes(svg_2_anti_bridge);

// TODO: color code the corners by how many edges they are adjacent to
// TODO: color code the edges by whether they are connected to leaves or between branch points
// TODO: color code edges that are the middle of a C shape
// TODO: color code corners that are adjacent to two edges and are one edge in from an endpoint and twist clockwise coming from that direction (to tell apart mirror images)

</script>
</html>