<html>
<body>
<h1>How many incomplete cubes are there?</h1>
<p style="text-indent:40px;">This investigation was inspired by a <a href="https://www.youtube.com/watch?v=_BrFKp-U8GI">3Blue1Brown guest video</a> written by Paul Dancstep.</p>
<p style="text-indent:40px;">The question presented in the video is, how many distinct subsets of the set of edges of a cube are there, or how many colorings of the edges of a cube are there, given the following constraints:</p>
<p style="text-indent:80px;"><tt>1) The colored edges must be connected.</tt></p>
<p style="text-indent:80px;"><tt>2) Rotationally equivalent colorings are excluded.</tt></p>
<p style="text-indent:80px;"><tt>3) Colorings that fit within a plane or on one side of the cube are excluded.</tt></p>
<p style="text-indent:80px;"><tt>4) The empty coloring and complete coloring are excluded.</tt></p>
<p style="text-indent:40px;">These guidelines will be modified slightly here. Instead of looking only at connected cubes, we will look at cubes with various numbers of connected colored components, and will not worry much about points 3 and 4. </p>
<p style="text-indent:40px;">First there will be an automated enumeration of all the cubes, and then a theoretical discussion.</p>
<h1 id="svgh0">Rotationally distinct cubes with 0 edges</h1>
<svg id="svg0" height="0" width="0" xmlns="http://www.w3.org/2000/svg">
<h1 id="svgh1">Rotationally distinct cubes with 1 edge</h1>
<svg id="svg1" height="0" width="0" xmlns="http://www.w3.org/2000/svg">
<h1 id="svgh2">Rotationally distinct cubes with 2 edges</h1>
<svg id="svg2" height="0" width="0" xmlns="http://www.w3.org/2000/svg">
<h1 id="svgh3">Rotationally distinct cubes with 3 edges</h1>
<svg id="svg3" height="0" width="0" xmlns="http://www.w3.org/2000/svg">
<h1 id="svgh4">Rotationally distinct cubes with 4 edges</h1>
<svg id="svg4" height="0" width="0" xmlns="http://www.w3.org/2000/svg">
<h1 id="svgh5">Rotationally distinct cubes with 5 edges</h1>
<svg id="svg5" height="0" width="0" xmlns="http://www.w3.org/2000/svg">
<h1 id="svgh6">Rotationally distinct cubes with 6 edges</h1>
<svg id="svg6" height="0" width="0" xmlns="http://www.w3.org/2000/svg">
<h1 id="svgh7">Rotationally distinct cubes with 7 edges</h1>
<svg id="svg7" height="0" width="0" xmlns="http://www.w3.org/2000/svg">
<h1 id="svgh8">Rotationally distinct cubes with 8 edges</h1>
<svg id="svg8" height="0" width="0" xmlns="http://www.w3.org/2000/svg">
<h1 id="svgh9">Rotationally distinct cubes with 9 edges</h1>
<svg id="svg9" height="0" width="0" xmlns="http://www.w3.org/2000/svg">
<h1 id="svgh10">Rotationally distinct cubes with 10 edges</h1>
<svg id="svg10" height="0" width="0" xmlns="http://www.w3.org/2000/svg">
<h1 id="svgh11">Rotationally distinct cubes with 11 edges</h1>
<svg id="svg11" height="0" width="0" xmlns="http://www.w3.org/2000/svg">
<h1 id="svgh12">Rotationally distinct cubes with 12 edges</h1>
<svg id="svg12" height="0" width="0" xmlns="http://www.w3.org/2000/svg">
</svg>

</body>
<script>


// TODO: list out rotation matrices (done)
// TODO: create cube data structure
// TODO: function to apply rotation matrix to cube
// TODO: function to compare cubes
// TODO: function to loop over possible cubes and compare them
// TODO: list of unique cubes
// TODO: display cube in simplified form in svg (done)
// TODO: display array of cubes in simplified form in svg
// TODO: filter cubes to remove disconnected, empty, full, 2D cases
// TODO: verify each rotation matrix by applying it to its axis vector and checking that there is no change
// TODO: create a loop that counts a numeric variable up but then interprets each bit as a flag for each edge in a cube


rotIdentity = 
 [[ 1, 0, 0],
  [ 0, 1, 0],
  [ 0, 0, 1]]
rotX90 = 
 [[ 1, 0, 0],
  [ 0, 0,-1],
  [ 0, 1, 0]]
rotX180 = 
 [[ 1, 0, 0],
  [ 0,-1, 0],
  [ 0, 0,-1]]
rotX270 = 
 [[ 1, 0, 0],
  [ 0, 0, 1],
  [ 0,-1, 0]]
rotY90 = 
 [[ 0, 0,-1],
  [ 0, 1, 0],
  [ 1, 0, 0]]
rotY180 = 
 [[-1, 0, 0],
  [ 0, 1, 0],
  [ 0, 0,-1]]
rotY270 = 
 [[ 0, 0, 1],
  [ 0, 1, 0],
  [-1, 0, 0]]
rotZ90 = 
 [[ 0,-1, 0],
  [ 1, 0, 0],
  [ 0, 0, 1]]
rotZ180 = 
 [[-1, 0, 0],
  [ 0,-1, 0],
  [ 0, 0, 1]]
rotZ270 = 
 [[ 0, 1, 0],
  [-1, 0, 0],
  [ 0, 0, 1]]
rotEdgeXPos = 
 [[-1, 0, 0],
  [ 0, 0, 1],
  [ 0, 1, 0]]
rotEdgeXNeg = 
 [[-1, 0, 0],
  [ 0, 0,-1],
  [ 0,-1, 0]]
rotEdgeYPos = 
 [[ 0, 0, 1],
  [ 0,-1, 0],
  [ 1, 0, 0]]
rotEdgeYNeg = 
 [[ 0, 0,-1],
  [ 0,-1, 0],
  [-1, 0, 0]]
rotEdgeZPos = 
 [[ 0, 1, 0],
  [ 1, 0, 0],
  [ 0, 0,-1]]
rotEdgeZNeg = 
 [[ 0,-1, 0],
  [-1, 0, 0],
  [ 0, 0,-1]]
rotCornerXYZ120 = 
 [[ 0, 0, 1],
  [ 1, 0, 0],
  [ 0, 1, 0]]
rotCornerXYZ240 = 
 [[ 0, 1, 0],
  [ 0, 0, 1],
  [ 1, 0, 0]]
rotCornerX120 = 
 [[ 0, 0,-1],
  [-1, 0, 0],
  [ 0, 1, 0]]
rotCornerX240 = 
 [[ 0,-1, 0],
  [ 0, 0, 1],
  [-1, 0, 0]]
rotCornerY120 = 
 [[ 0, 0, 1],
  [-1, 0, 0],
  [ 0,-1, 0]]
rotCornerY240 = 
 [[ 0,-1, 0],
  [ 0, 0,-1],
  [ 1, 0, 0]]
rotCornerZ120 = 
 [[ 0, 0,-1],
  [ 1, 0, 0],
  [ 0,-1, 0]]
rotCornerZ240 = 
 [[ 0, 1, 0],
  [ 0, 0,-1],
  [-1, 0, 0]]

rotations = 
 [rotIdentity,
  rotX90,
  rotX180,
  rotX270,
  rotY90,
  rotY180,
  rotY270,
  rotZ90,
  rotZ180,
  rotZ270,
  rotEdgeXPos,
  rotEdgeXNeg,
  rotEdgeYPos,
  rotEdgeYNeg,
  rotEdgeZPos,
  rotEdgeZNeg,
  rotCornerXYZ120,
  rotCornerXYZ240,
  rotCornerX120,
  rotCornerX240,
  rotCornerY120,
  rotCornerY240,
  rotCornerZ120,
  rotCornerZ240]

completeCube = 
 [[[0,1,0],
   [1,0,1],
   [0,1,0]],
  [[1,0,1],
   [0,0,0],
   [1,0,1]],
  [[0,1,0],
   [1,0,1],
   [0,1,0]]]

cubeEdgeCoordinates = 
 [[0,0,1],
  [0,1,0],
  [0,1,2],
  [0,2,1],
  [1,0,0],
  [1,0,2],
  [1,2,0],
  [1,2,2],
  [2,0,1],
  [2,1,0],
  [2,1,2],
  [2,2,1]]

cubeEdgeCoordinates2 = 
 [[ 6,[-1,-1, 0]],
  [ 5,[-1, 0,-1]],
  [12,[-1, 0, 1]],
  [10,[-1, 1, 0]],
  [11,[ 0,-1,-1]],
  [ 1,[ 0,-1, 1]],
  [ 4,[ 0, 1,-1]],
  [ 8,[ 0, 1, 1]],
  [ 7,[ 1,-1, 0]],
  [ 9,[ 1, 0,-1]],
  [ 2,[ 1, 0, 1]],
  [ 3,[ 1, 1, 0]]]

cubeEdgeIndices = 
 [[[ 0, 0, 0],
   [ 1, 0, 2],
   [ 0, 3, 0]],
  [[ 4, 0, 5],
   [ 0, 0, 0],
   [ 6, 0, 7]],
  [[ 0, 8, 0],
   [ 9, 0,10],
   [ 0,11, 0]]]

neighborIndices =
 [[1,2,4,5],
  [0,3,4,6],
  [0,3,5,7],
  [1,2,6,7],
  [0,1,8,9],
  [0,2,8,10],
  [1,3,9,11],
  [2,3,10,11],
  [4,5,9,10],
  [4,6,8,11],
  [5,7,8,11],
  [6,7,9,10]]

function cubeEdgeToIndex(edge) {
	let newEdge = cubeEdgeIndices[edge[0]+1][edge[1]+1][edge[2]+1];
	return newEdge
}

function cubeIndexToEdge(index) {
	return cubeEdgeCoordinates2[index][1];
}

function applyRotationToEdge(matrix,edge) {
	let newEdge = [0,0,0];
	for(let r=0; r<3; r++) {
		let tmp = 0;
		for(let c=0; c<3; c++) {
			tmp += matrix[r][c]*edge[c];
		}
		newEdge[r] = tmp;
	}
	return newEdge;
}

function applyRotationToIndex(matrix,index) {
	let edge = cubeIndexToEdge(index);
	let newEdge = applyRotationToEdge(matrix,edge);
	let newIndex = cubeEdgeToIndex(newEdge);
	return newIndex;
}

function cubeToIndices(cube) {
	let indices = [0,0,0,0,0,0,0,0,0,0,0,0];
	for(let k=0; k<12; k++) {
		let bit = (cube>>k)&1;
		if(bit==1) {
			indices[k] = 1;
		}
	}
	return indices;
}

function indicesToCube(indices) {
	let cube = 0;
	for(let k=0; k<12; k++) {
		let bit = indices[k];
		cube = cube|(bit<<k);
	}
	return cube;
}

function rotateCube(matrix,cube) {
	let indices = cubeToIndices(cube);
	let newIndices = [0,0,0,0,0,0,0,0,0,0,0,0];
	for(let k=0; k<12; k++) {
		let bit = indices[k];
		if(bit) {
			let newIndex = applyRotationToIndex(matrix,k);
			newIndices[newIndex] = 1;
		}
	}
	let newCube = indicesToCube(newIndices);
	return newCube;
}

function displayCube(bits) {
	for(let k=0; k<12; k++) {
		let edgeId = cubeEdgeCoordinates2[k][0];
		let bit = (bits>>k)&1;
		if(bit==1) {
			document.getElementById("e"+edgeId).style.opacity = "1";
		} else {
			document.getElementById("e"+edgeId).style.opacity = "0";
		}
	}
}

function displayRandomCube() {
	displayCube(Math.floor(Math.random()*4096));
}

//displayRandomCube();
//displayCube(rotateCube(rotations[23],14));

let distinctCubes = [];

function iterateOverCubes() {
	for(let bits=0; bits<4096; bits++) {
		let duplicate = 0;
		for(let rotationIndex=0; rotationIndex<24; rotationIndex++) {
			rotation = rotations[rotationIndex];
			let newBits = rotateCube(rotation,bits);
			if(distinctCubes.includes(newBits)) {
				duplicate = 1;
				continue;
			}
		}
		if(duplicate==0) {
			distinctCubes.push(bits);
		}
	}
	console.log(distinctCubes.length);
}

iterateOverCubes();

//displayCube(distinctCubes[175]);

function cubePointToScreenPointAsHexagon(x,y,z,xmax) {
	// 0,0,0 on the cube maps to 0,0 on the screen
	// -1,1,1 and 1,-1,-1 on the cube map to 0,0 on the screen
	// screen points will be within ([-xmax,xmax],[-xmax,xmax]) bounding box
	let r3 = 1.732;
	let screenPoint = [0,0];
	screenPoint[0] = Math.round((0.5*x+0.25*y+0.25*z)*xmax);
	screenPoint[1] = Math.round((0.0*x+0.25*r3*y-0.25*r3*z)*xmax);
	return screenPoint;
}

function cubePointToScreenPointAsSquare(x,y,z,xmax) {
	// 0,0,0 on the cube maps to 0,0 on the screen
	// 0,0,1 and 0,0,-1 on the cube map to 0,0 on the screen
	// screen points will be within ([-xmax,xmax],[-xmax,xmax]) bounding box
	let screenPoint = [0,0];
	screenPoint[0] = Math.round(x*(0.66+0.33*z)*xmax);
	screenPoint[1] = Math.round(y*(0.66+0.33*z)*xmax);
	return screenPoint;
}

function paintCorner(svg,x,y,z,offsetX,offsetY,size) {
	//let screenPoint = cubePointToScreenPointAsHexagon(x,y,z,size);
	let screenPoint = cubePointToScreenPointAsSquare(x,y,z,size);
	let circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
	svg.appendChild(circle);
	//circle.setAttribute("r","2");
	circle.setAttribute("r","1");
	circle.setAttribute("cx",""+(screenPoint[0]+offsetX));
	circle.setAttribute("cy",""+(screenPoint[1]+offsetY));
	circle.setAttribute("fill","black");
}

function paintEdge(svg, edge, offsetX, offsetY, size) {
	let x1 = edge[0]==0?-1:edge[0];
	let y1 = edge[1]==0?-1:edge[1];
	let z1 = edge[2]==0?-1:edge[2];
	let x2 = edge[0]==0?1:edge[0];
	let y2 = edge[1]==0?1:edge[1];
	let z2 = edge[2]==0?1:edge[2];
	//let screenPoint1 = cubePointToScreenPointAsHexagon(x1,y1,z1,size);
	//let screenPoint2 = cubePointToScreenPointAsHexagon(x2,y2,z2,size);
	let screenPoint1 = cubePointToScreenPointAsSquare(x1,y1,z1,size);
	let screenPoint2 = cubePointToScreenPointAsSquare(x2,y2,z2,size);
	let polygon = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
	svg.appendChild(polygon);
	polygon.setAttribute("style", "fill:black;stroke:black;stroke-width:1");
	let point1 = svg.createSVGPoint();
	point1.x = screenPoint1[0]+offsetX;
	point1.y = screenPoint1[1]+offsetY;
	polygon.points.appendItem(point1);
	let point2 = svg.createSVGPoint();
	point2.x = screenPoint2[0]+offsetX;
	point2.y = screenPoint2[1]+offsetY;
	polygon.points.appendItem(point2);
}

function paintCube(svg, cube, offsetX, offsetY, size) {
	let indices = cubeToIndices(cube);
	for(let k=0; k<12; k++) {
		let bit = indices[k];
		if(bit) {
			let edge = cubeEdgeCoordinates2[k][1];
			paintEdge(svg,edge,offsetX,offsetY,size);
		}
	}
	for(let x=-1; x<=1; x+=2) {
		for(let y=-1; y<=1; y+=2) {
			for(let z=-1; z<=1; z+=2) {
				paintCorner(svg,x,y,z,offsetX,offsetY,size);
			}
		}
	}
}

function paintAllDistinctCubes(svg) {
	for(let c=0; c<15; c++) {
		for(let r=0; r<15; r++) {
			if(c*15+r>=distinctCubes.length) break;
			paintCube(svg,distinctCubes[c*15+r],r*40+20,c*40+20,10);
		}
	}
}

//paintAllDistinctCubes()

function countNumberOfEdges(bits) {
	let indices = cubeToIndices(bits);
	let numberOfEdges = 0;
	for(let k=0; k<12; k++) {
		if(indices[k]==1) {
			numberOfEdges++;
		}
	}
	return numberOfEdges;
}

function countNumberOfConnectedComponents(bits) {
	let indices = cubeToIndices(bits);
	let visited = [0,0,0,0,0,0,0,0,0,0,0,0];
	let numberOfConnectedComponents = 0;
	while(true) {
		let finished = 1;
		for(let k=0; k<12; k++) {
			if(indices[k]==1&&visited[k]==0) {
				finished = 0;
				numberOfConnectedComponents++;
				visited[k] = 1;
				break;
			}
		}
		if(finished==1) break;
		while(true) {
			let componentFinished = 1;
			for(let k=0; k<12; k++) {
				if(indices[k]==0) continue;
				if(visited[k]==1) {
					visited[k] = 2;
					componentFinished = 0;
					let neighbors = neighborIndices[k];
					for(let n=0; n<neighbors.length; n++) {
						let neighbor = neighbors[n];
						if(indices[neighbor]==0) continue;
						if(visited[neighbor]==0) {
							visited[neighbor] = 1;
						}
					}
				}
			}
			if(componentFinished==1) break;
		}
	}
	return numberOfConnectedComponents;
}

// stratified by number of connected components and then number of edges
let stratifiedCubes = 
 [[[],[],[],[],[],[],[],[],[],[],[],[],[]],
  [[],[],[],[],[],[],[],[],[],[],[],[],[]],
  [[],[],[],[],[],[],[],[],[],[],[],[],[]],
  [[],[],[],[],[],[],[],[],[],[],[],[],[]],
  [[],[],[],[],[],[],[],[],[],[],[],[],[]]]

function stratifyDistinctCubes() {
	for(let k=0; k<distinctCubes.length; k++) {
		let bits = distinctCubes[k];
		let numberOfEdges = countNumberOfEdges(bits);
		let numberOfConnectedComponents = countNumberOfConnectedComponents(bits);
		stratifiedCubes[numberOfConnectedComponents][numberOfEdges].push(bits);
	}
}

stratifyDistinctCubes();

console.log(stratifiedCubes);


function paintLine(svg,p1,p2) {
	let line = document.createElementNS("http://www.w3.org/2000/svg", "line");
	line.setAttribute("style", "stroke:black;stroke-width:1");
	svg.appendChild(line);
	line.setAttribute("x1",p1[0]);
	line.setAttribute("y1",p1[1]);
	line.setAttribute("x2",p2[0]);
	line.setAttribute("y2",p2[1]);
}

function paintText(svg,x,y,textContent) {
	let text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
	text.setAttribute('x',x);
	text.setAttribute('y',y);
	text.setAttribute('fill','#000');
	text.setAttribute("style","font-size:20px;");
	text.textContent = textContent;
	svg.appendChild(text); 
}

function paintFrame(svg,width,height) {
	paintLine(svg,[0,0],[width,0]);
	paintLine(svg,[width,0],[width,height]);
	paintLine(svg,[width,height],[0,height]);
	paintLine(svg,[0,height],[0,0]);
}

function paintAllDistinctStratifiedCubes(svg,svgh,numberOfEdges) {
	// TODO: swap r and c for readability?
	let r = -1;
	let c = -2;
	let numberOfCubes = 0;
	for(let numberOfConnectedComponents=0; numberOfConnectedComponents<5; numberOfConnectedComponents++) {
		let cubes = stratifiedCubes[numberOfConnectedComponents][numberOfEdges];
		if(cubes.length>0) {
			c += 2;
			r = -1;
			let componentsText = numberOfConnectedComponents==1?" Connected component":" Connected components";
			paintText(svg,10,c*40+30,numberOfConnectedComponents+componentsText+" ("+cubes.length+" cube"+(cubes.length==1?"":"s")+")");
			for(let k=0; k<cubes.length; k++) {
				r++;
				if(r==15) {
					r = 0;
					c++;
				}
				paintCube(svg,cubes[k],r*40+20,(c+1)*40+20,10);
				numberOfCubes++;
			}
		}
	}
	let h = (c+2)*40+10;
	svg.setAttribute('width','800');
	svg.setAttribute('height',h);
	paintFrame(svg,800,h);
	svgh.innerText = "Rotationally distinct cubes with "+numberOfEdges+" edge"+(numberOfEdges==1?"":"s")+" ("+numberOfCubes+" cube"+(numberOfCubes==1?"":"s")+")";
}

// TODO: this is working even though svg0 etc are not declared variables, how standard is that across browsers?
paintAllDistinctStratifiedCubes(svg0,svgh0,0);
paintAllDistinctStratifiedCubes(svg1,svgh1,1);
paintAllDistinctStratifiedCubes(svg2,svgh2,2);
paintAllDistinctStratifiedCubes(svg3,svgh3,3);
paintAllDistinctStratifiedCubes(svg4,svgh4,4);
paintAllDistinctStratifiedCubes(svg5,svgh5,5);
paintAllDistinctStratifiedCubes(svg6,svgh6,6);
paintAllDistinctStratifiedCubes(svg7,svgh7,7);
paintAllDistinctStratifiedCubes(svg8,svgh8,8);
paintAllDistinctStratifiedCubes(svg9,svgh9,9);
paintAllDistinctStratifiedCubes(svg10,svgh10,10);
paintAllDistinctStratifiedCubes(svg11,svgh11,11);
paintAllDistinctStratifiedCubes(svg12,svgh12,12);


// TODO: color code the corners by how many edges they are adjacent to
// TODO: color code the edges by whether they are connected to leaves or between branch points
// TODO: color code edges that are the middle of a C shape
// TODO: color code corners that are adjacent to two edges and are one edge in from an endpoint and twist clockwise coming from that direction (to tell apart mirror images)

</script>
</html>