<html>
<body>
<select id="curveSelect" onchange="selectCurve()" style="font-size:50px;">
  <option value="parabola" selected>parabola</option>
  <option value="circle">circle</option>
  <option value="twist">twist</option>
  <option value="spiral">spiral</option>
</select>
<select id="numberSelect" onchange="selectNumber()" style="font-size:50px;">
  <option value="1">1</option>
  <option value="2">2</option>
  <option value="3">3</option>
  <option value="4">4</option>
  <option value="5">5</option>
  <option value="6">6</option>
  <option value="7">7</option>
  <option value="8">8</option>
  <option value="9">9</option>
  <option value="10" selected>10</option>
  <option value="20">20</option>
  <option value="50">50</option>
  <option value="100">100</option>
  <option value="1000">1000</option>
</select>
<input type="checkbox" id="OptimizeCheckbox" onchange="optimize()" style="width:50px;height:50px;"> <span style="font-size:50px;">Optimize</span>
<p/>
<svg id="svg" height="600" width="800" xmlns="http://www.w3.org/2000/svg">
</svg>
</body>
<script>
var svg = document.getElementById("svg");

/*

Interactive tool to visualize approximation of the length of a curve by line segments
TODO: draw curve from formula
	Recursive subdivision or parametrized?
TODO: offer user control points or sliders/textbox/etc to modify shape of curve
TODO: offer user clickable interval to add/remove endpoints of line segments to be mapped to curve
TODO: allow user to add/remove line segment endpoints directly on rendered curve
TODO: allow user to drag line segment endpoints along curve
TODO: summarize all total lengths visited so far on colored bar along with marked supremum/maximum value for length of curve
TODO: for a given number of line segments, what endpoints would give the closest approximation to the length of the curve?

*/

var selectedCurve = "parabola";

function getCurvePoint(t) {
	// t is between 0 and 1
	var point = [0,0];
	if(selectedCurve=="parabola") {
		point[0] = t*400+100;
		point[1] = (2*t-1)*(2*t-1)*500+10;
	} else if(selectedCurve=="circle") {
		// circle (rectangular coordinates)
		point[0] = t*400+100;
		point[1] = Math.sqrt(1-(2*t-1)*(2*t-1))*200+200;
		// circle (polar coordinates)
		//point[0] = Math.cos(t*Math.PI)*200+300;
		//point[1] = Math.sin(t*Math.PI)*200+200;
	} else if(selectedCurve=="twist") {
		point[0] = -Math.cos(t*2*Math.PI)*200+300;
		point[1] = Math.cos(t*5*Math.PI)*200+300;
	} else if(selectedCurve=="spiral") {
		point[0] = t*Math.cos(t*6*Math.PI)*200+300;
		point[1] = t*Math.sin(t*6*Math.PI)*200+300;
	} else {
		console.log("Error - selectedCurve value ("+selectedCurve+") not recognized");
	}
	return point;
}

function adjacent(p1,p2) {
	var a = p2[0]-p1[0];
	var b = p2[1]-p1[1];
	return (a*a+b*b)<1;
}

var linesPainted = [];

function paintLine(p1,p2) {
	var line = document.createElementNS("http://www.w3.org/2000/svg", "line");
	line.setAttribute("style", "stroke:black;stroke-width:1");
	svg.appendChild(line);
	line.setAttribute("x1",p1[0]);
	line.setAttribute("y1",p1[1]);
	line.setAttribute("x2",p2[0]);
	line.setAttribute("y2",p2[1]);
	linesPainted.push(line);
}

var curveDistanceSum = 0;

function paintCurve(t1,t2) {
	var p1 = getCurvePoint(t1);
	var p2 = getCurvePoint(t2);
	if(adjacent(p1,p2)) {
		paintLine(p1,p2);
		curveDistanceSum += distance(p1,p2);
	} else {
		var mid = 0.5*(t1+t2);
		paintCurve(t1,mid);
		paintCurve(mid,t2);
	}
}

paintCurve(0,1);

var cornerTimes = 
 [0.0,
  1.0]

var numberOfSegments = 10;

function setCornerTimes() {
	cornerTimes = [];
	var n = numberOfSegments;
	for(var k=0; k<=n; k++) {
		cornerTimes.push(k*1.0/n);
	}
}

setCornerTimes();

function distance3times(t0,t1,t2) {
	var p0 = getCurvePoint(t0);
	var p1 = getCurvePoint(t1);
	var p2 = getCurvePoint(t2);
	var d0 = distance(p0,p1);
	var d2 = distance(p1,p2);
	return d0+d2;
}

var shouldOptimizeCornerTimes = false;

function optimizeCornerTimes() {
	if(!shouldOptimizeCornerTimes) return;
	if(cornerTimes.length<2) return;
	// TODO: consider how best to optimize endpoints
	cornerTimes[0] = 0.0;
	cornerTimes[cornerTimes.length-1] = 1.0;
	var epsilon = 0.2;
	var cycles = 0;
	while(true) {
		cycles++;
		var delta = 0;
		for(var k=1; k<cornerTimes.length-1; k++) {
			var t0 = cornerTimes[k-1];
			var t1 = cornerTimes[k];
			var t2 = cornerTimes[k+1];
			var epsilon1 = epsilon*(t1-t0);
			var epsilon2 = epsilon*(t2-t1);
			var d = distance3times(t0,t1,t2);
			var dminus = distance3times(t0,t1-epsilon1,t2);
			var dplus = distance3times(t0,t1+epsilon2,t2);
			if(dplus<dminus&&d<dminus) {
				cornerTimes[k] = t1-epsilon1;
				delta += dminus-d;
			} else if(dplus>d&&dplus>dminus) {
				cornerTimes[k] = t1+epsilon2;
				delta += dplus-d;
			}
		}
		if(delta<0.1&&epsilon<0.001) break;
		epsilon = epsilon*0.9;
	}
	console.log(cycles);
}

optimizeCornerTimes();

var lineDistanceSum = 0;

function calculateLineDistanceSum() {
	lineDistanceSum = 0;
	for(var k=0; k<cornerTimes.length-1; k++) {
		var t1 = cornerTimes[k];
		var t2 = cornerTimes[k+1];
		var p1 = getCurvePoint(t1);
		var p2 = getCurvePoint(t2);
		lineDistanceSum += distance(p1,p2);
	}
}

calculateLineDistanceSum();

function paintLinearApproximation() {
	for(var k=0; k<cornerTimes.length-1; k++) {
		var t1 = cornerTimes[k];
		var t2 = cornerTimes[k+1];
		var p1 = getCurvePoint(t1);
		var p2 = getCurvePoint(t2);
		paintLine(p1,p2);
	}
}

paintLinearApproximation();


// TODO: paint these intervals more nicely and label them

function paintInputInterval() {
	paintLine([650,100],[750,100]);
	paintLine([650,90],[650,110]);
	paintLine([750,90],[750,110]);
	for(var k=0; k<cornerTimes.length; k++) {
		var s = cornerTimes[k]*100+650;
		var p1 = [s,90];
		var p2 = [s,110];
		paintLine(p1,p2);
	}
}

paintInputInterval();

function distance(p1,p2) {
	var a = p2[0]-p1[0];
	var b = p2[1]-p1[1];
	return Math.sqrt(a*a+b*b);
}

function paintOutputInterval() {
	paintLine([650,300],[750,300]);
	paintLine([650,290],[650,310]);
	paintLine([750,290],[750,310]);
	console.log(lineDistanceSum);
	console.log(curveDistanceSum);
	var t = lineDistanceSum/curveDistanceSum;
	console.log(100*t);
	var s = t*100+650;
	var p1 = [s,290];
	var p2 = [s,310];
	paintLine(p1,p2);
}

paintOutputInterval();

function paintLogOutputInterval() {
	paintLine([650,500],[750,500]);
	paintLine([650,490],[650,510]);
	paintLine([750,490],[750,510]);
	var t = Math.log(1-lineDistanceSum/curveDistanceSum)/Math.LN2;
	var t = -0.1*(t+2);
	console.log(t);
	if(t>=0&&t<=1) {
		var s = t*100+650;
		var p1 = [s,490];
		var p2 = [s,510];
		paintLine(p1,p2);
	}
}

paintLogOutputInterval();

function redraw() {
	for(var k=0; k<linesPainted.length; k++) {
		linesPainted[k].remove();
	}
	linesPainted = [];
	curveDistanceSum = 0;
	paintCurve(0,1);
	cornerTimes = [0.0, 1.0]
	setCornerTimes();
	optimizeCornerTimes();
	lineDistanceSum = 0;
	calculateLineDistanceSum();
	paintLinearApproximation();
	paintInputInterval();
	paintOutputInterval();
	paintLogOutputInterval();
}

function selectNumber() {
	numberOfSegments = document.getElementById("numberSelect").value;
	redraw();
}

function optimize() {
	shouldOptimizeCornerTimes = document.getElementById("OptimizeCheckbox").checked;
	redraw();
}

function selectCurve() {
	selectedCurve = document.getElementById("curveSelect").value;
	redraw();
}

</script>
</html>