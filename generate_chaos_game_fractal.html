<html>
<body>
<!-- TODO: insert user controls -->
<span style="font-size:50px;">Curve:</span>
<span style="padding-left:5px;padding-right:5px;">
  <select id="curveSelect" name="selectedCurve" onchange="selectCurve()" style="font-size:50px;padding-left:5px;padding-right:5px;">
    <option value="1">1</option>
    <option value="2">2</option>
    <option value="3">3</option>
    <option value="4" selected>4</option>
  </select>
</span>
<span style="font-size:50px;">Detail:</span>
<span style="padding-left:5px;">
  <select id="numberSelect" name="selectedNumber" onchange="selectNumber()" style="font-size:50px;padding-left:5px;padding-right:5px;">
    <option value="10">10</option>
    <option value="100">100</option>
    <option value="1000">1000</option>
    <option value="10000" selected>10000</option>
    <option value="100000">100000</option>
    <option value="1000000">1000000</option>
  </select>
</span>
<p/>

<table id="configsTable" style="width:800px;">
  <!--tr>
    <td style="width:400px;">
     <span style="font-size:50px;">Detail:</span>
     <span style="padding-left:5px;">
       <select id="numberSelect" name="selectedNumber" onchange="selectNumber()" style="font-size:50px;padding-left:5px;padding-right:5px;">
         <option value="1">1</option>
         <option value="2">2</option>
         <option value="3">3</option>
         <option value="4">4</option>
         <option value="5">5</option>
         <option value="6" selected>6</option>
         <option value="7">7</option>
         <option value="8">8</option>
         <option value="9">9</option>
         <option value="10">10</option>
       </select>
     </span>
    </td>
    <td>
     <span style="font-size:50px;" onclick="filledTextClicked()">Filled:</span>
     <input type="checkbox" id="FilledCheckbox" onchange="filledCheckboxClicked()" style="width:50px;height:50px;padding-left:5px;" checked="true">
    </td>
  </tr-->
</table>
<p/>
<svg id="svg" height="600" width="800" xmlns="http://www.w3.org/2000/svg">
</svg>
</body>
<script>
let svg = document.getElementById("svg");
let levelOfIteration;
let sizeOfPoints;
let selectedCurve;
let selectedTransforms;
let sierpinskiTriangleTransforms = [
	[[   0,   0],[0.5,0]],
	[[ 0.5,   0],[0.5,0]],
	[[0.25,-0.5],[0.5,0]]
];
let sierpinskiCarpetTransforms = [
	[[       0,        0],[0.333333,0]],
	[[0.333333,        0],[0.333333,0]],
	[[0.666667,        0],[0.333333,0]],
	[[       0,-0.333333],[0.333333,0]],
	[[0.666667,-0.333333],[0.333333,0]],
	[[       0,-0.666667],[0.333333,0]],
	[[0.333333,-0.666667],[0.333333,0]],
	[[0.666667,-0.666667],[0.333333,0]],
];
let transform3 = [
	[[   0,   0],[0.39,0],[0.0,0]],
	[[ 0.5,   0],[0.39,0],[0.1,0]],
	[[0.25,-0.5],[0.39,0],[0.2,0]]
];
let transform4 = [
	[[ 0.5,   0],[0.39,0],[-0.15,0]],
	[[ 0,   0],[0.39,0],[0,0]],
	[[0.5,-0.5],[0.39,0],[0.15,0]]
];


// TODO: initialize these values by reading from the html or vice versa
// TODO: global variables like svg width and height, number of points to draw, and selected curve
function calculateSizeOfPoints() {
	sizeOfPoints = 0.2;
	if(levelOfIteration<=100) {
		sizeOfPoints = 10;
	} else if(levelOfIteration<=10000) {
		sizeOfPoints = 1;
	}
}
function selectTransforms() {
	if(selectedCurve=="1") {
		selectedTransforms = structuredClone(sierpinskiTriangleTransforms);
	} else if(selectedCurve=="2") {
		selectedTransforms = structuredClone(sierpinskiCarpetTransforms);
	} else if(selectedCurve=="3") {
		selectedTransforms = structuredClone(transform3);
	} else if(selectedCurve=="4") {
		selectedTransforms = structuredClone(transform4);
	}
}
function initializeGlobalVariables() {
	levelOfIteration = Number(document.getElementById("numberSelect").value);
	selectedCurve = document.getElementById("curveSelect").value;
	calculateSizeOfPoints();
	selectTransforms();
}
initializeGlobalVariables();

/*

Chaos Game fractal generator

TODO: chaos game iterating simple complex-coefficient polynomials eg az+b or az^2+bz+c
TODO: allow user to select from predefined interesting configurations
TODO: allow user to input custom configurations for a fixed number of generators
TODO: allow user to specify a variable-length list of generators
TODO: allow user to specify bounds of viewing box
TODO: ensure even coverage by biasing iteration towards low density areas
	Maybe measure standard deviation of points after each transformation and bias based on that
TODO: maybe take the whole thing as like a dynamic programming problem, just have a two dimensional array of what points have been colored black previously and recently, and at each step all the last stage colored black are moved through all the transformations and any new black cells are the next stage, might not work perfectly if the path from one point to another does not align well with the grid

*/

let drawnPoints = [];

function drawPoint(point) {
	let x = point[0];
	let y = point[1];
	let circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
	circle.setAttribute('cx', x);
	circle.setAttribute('cy', y);
	circle.setAttribute('r', sizeOfPoints);
	circle.setAttribute('fill', "black");
	circle.setAttribute('fill', "black");
	svg.appendChild(circle);
	drawnPoints.push(circle);
}

// functions to apply arithmetic operations to complex numbers
function plus(a,b) {
	return [
		a[0]+b[0],
		a[1]+b[1]
	];
}
function times(a,b) {
	return [
		a[0]*b[0]-a[1]*b[1],
		a[0]*b[1]+a[1]*b[0]
	];
}
function pow(z,n) {
	let zNext = [1,0];
	for(let k=0; k<n; k++) {
		zNext = times(zNext,z);
	}
	return zNext;
}

let varianceData = [];

function storeVarianceData(z,k) {
	varianceData.push([z,k]);
}
function calculateVarianceData() {
	// iterate over the list splitting it up by k-value
	//   could start with just k=3
	// in each k-group
	//   find the X-mean and Y-mean
	//     sum up over all point values and divide by count
	//     running sum of values and running sum of 1 for counts
	//   find the X-variance and Y-variance
	//     for each point find the squared deviation
	//     sum up over all points
	//     divide by one less than number of points
	//   find the overall variance and standard deviation
	let sumX = 0;
	for(let n=0; n<varianceData.length; n++) {
		let data = varianceData[n];
		let x = data[0][0];
		let y = data[0][1];
		let k = data[1];
		
	}
}

// TODO: may need to use roots instead of powers to get something that converges
// TODO: include generic affine transformations such as squeezing in only one direction
// apply polynomial to a complex valued input
function applyTransformation(z,transformation) {
	let zNext = [0,0];
	for(let k=0; k<transformation.length; k++) {
		let c = transformation[k];
		zNext = plus(zNext,times(c,pow(z,k)));
		storeVarianceData(zNext,k);
	}
	return zNext;
}

function convertPointToScreen(z) {
	return [
		300*z[0]+300,
		300*z[1]+400
	];
}

function deleteTableRow(rowId) {
	selectedTransforms.splice(rowId,1);
	redraw();
}

function createTable(transforms) {
	// TODO: add column for probability bias
	// TODO: allow user to modify values
	// TODO: allow user to add and delete rows
	// TODO: add column headers or additional columns with static data explaining what each column is for
	configsTable = document.getElementById("configsTable");
	configsTable.style.width = '800px';
	configsTable.style.border = '1px solid black';
	tableBody = configsTable.getElementsByTagName('tbody')[0];
	if(tableBody) {
		tableBody.innerHTML = ''; // Clears all content within the tbody
	}
	for(let i = 0; i < transforms.length; i++) {
		let tr = configsTable.insertRow();
		let td = tr.insertCell();
		td.style.width = '20px';
		td.style.border = '1px solid black';
		td.style.fontSize = '20px';
		td.style.textAlign = 'center';
		let minusButton = document.createElement("button");
		minusButton.innerText = "-";
		minusButton.onclick = function(event){deleteTableRow(i);};
		td.appendChild(minusButton);
		for(let j = 0; j < transforms[0].length; j++) {
			td = tr.insertCell();
			td.appendChild(document.createTextNode(transforms[i][j][0]+","+transforms[i][j][1]));
			td.style.width = (780.0/transforms[0].length)+'px';
			td.style.border = '1px solid black';
			td.style.fontSize = '20px';
		}
	}
}

function paintChaosGame() {
	let z = [1,0];
	let transforms = selectedTransforms;
	createTable(transforms);
	for(let k=0; k<levelOfIteration; k++) {
		// TODO: allow user to bias transform selection for artistic effect
		let transform = transforms[Math.floor(Math.random()*transforms.length)];
		//let transform = transforms[Math.floor(Math.pow(Math.random(),0.6)*transforms.length)];
		//let transform = transforms[[0,0,0,0,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2][Math.floor(Math.random()*21)]];
		//console.log(transform);
		z = applyTransformation(z,transform);
		//console.log(z);
		drawPoint(convertPointToScreen(z));
	}
	calculateVarianceData();
}

paintChaosGame();

function redraw() {
	for(let k=0; k<drawnPoints.length; k++) {
		drawnPoints[k].remove();
	}
	drawnPoints = [];
	paintChaosGame();
}

function selectCurve() {
	selectedCurve = document.getElementById("curveSelect").value;
	selectTransforms();
	redraw();
}

function selectNumber() {
	levelOfIteration = document.getElementById("numberSelect").value;
	calculateSizeOfPoints();
	redraw();
}

</script>
</html>