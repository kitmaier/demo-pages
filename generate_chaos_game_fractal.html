<html>
<body>
<!-- TODO: insert user controls -->
<span style="font-size:50px;">Curve:</span>
<span style="padding-left:5px;padding-right:5px;">
  <select id="curveSelect" name="selectedCurve" onchange="selectCurve()" style="font-size:50px;padding-left:5px;padding-right:5px;">
    <option value="1" selected>1</option>
    <option value="2">2</option>
    <option value="3">3</option>
  </select>
</span>
<span style="font-size:50px;">Detail:</span>
<span style="padding-left:5px;">
  <select id="numberSelect" name="selectedNumber" onchange="selectNumber()" style="font-size:50px;padding-left:5px;padding-right:5px;">
    <option value="10">10</option>
    <option value="100">100</option>
    <option value="1000">1000</option>
    <option value="10000" selected>10000</option>
    <option value="100000">100000</option>
    <option value="1000000">1000000</option>
  </select>
</span>
<p/>
<svg id="svg" height="600" width="800" xmlns="http://www.w3.org/2000/svg">
</svg>
</body>
<script>
var svg = document.getElementById("svg");
var levelOfIteration;
var sizeOfPoints;
var selectedCurve;

// TODO: initialize these values by reading from the html or vice versa
// TODO: global variables like svg width and height, number of points to draw, and selected curve
function calculateSizeOfPoints() {
	sizeOfPoints = 0.2;
	if(levelOfIteration<=100) {
		sizeOfPoints = 10;
	} else if(levelOfIteration<=10000) {
		sizeOfPoints = 1;
	}
}
function initializeGlobalVariables() {
	levelOfIteration = Number(document.getElementById("numberSelect").value);
	selectedCurve = document.getElementById("curveSelect").value;
	calculateSizeOfPoints();
}
initializeGlobalVariables();

/*

Chaos Game fractal generator

TODO: chaos game iterating simple complex-coefficient polynomials eg az+b or az^2+bz+c
TODO: allow user to select from predefined interesting configurations
TODO: allow user to input custom configurations for a fixed number of generators
TODO: allow user to specify a variable-length list of generators
TODO: allow user to specify bounds of viewing box
TODO: ensure even coverage by biasing iteration towards low density areas
	Maybe measure standard deviation of points after each transformation and bias based on that

*/

var drawnPoints = [];

function drawPoint(point) {
	var x = point[0];
	var y = point[1];
	var circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
	circle.setAttribute('cx', x);
	circle.setAttribute('cy', y);
	circle.setAttribute('r', sizeOfPoints);
	circle.setAttribute('fill', "black");
	circle.setAttribute('fill', "black");
	svg.appendChild(circle);
	drawnPoints.push(circle);
}

// functions to apply arithmetic operations to complex numbers
function plus(a,b) {
	return [
		a[0]+b[0],
		a[1]+b[1]
	];
}
function times(a,b) {
	return [
		a[0]*b[0]-a[1]*b[1],
		a[0]*b[1]+a[1]*b[0]
	];
}
function pow(z,n) {
	var zNext = [1,0];
	for(var k=0; k<n; k++) {
		zNext = times(zNext,z);
	}
	return zNext;
}

// TODO: may need to use roots instead of powers to get something that converges
// apply polynomial to a complex valued input
function applyTransformation(z,transformation) {
	var zNext = [0,0];
	for(var k=0; k<transformation.length; k++) {
		var c = transformation[k];
		zNext = plus(zNext,times(c,pow(z,k)));
	}
	return zNext;
}

function convertPointToScreen(z) {
	return [
		300*z[0]+300,
		300*z[1]+300
	];
}

function paintChaosGame() {
	var z = [1,0];
	var sierpinskiTriangleTransforms = [
		[[   0,   0],[0.5,0]],
		[[ 0.5,   0],[0.5,0]],
		[[0.25,-0.5],[0.5,0]]
	];
	var sierpinskiCarpetTransforms = [
		[[       0,        0],[0.333333,0]],
		[[0.333333,        0],[0.333333,0]],
		[[0.666667,        0],[0.333333,0]],
		[[       0,-0.333333],[0.333333,0]],
		[[0.666667,-0.333333],[0.333333,0]],
		[[       0,-0.666667],[0.333333,0]],
		[[0.333333,-0.666667],[0.333333,0]],
		[[0.666667,-0.666667],[0.333333,0]],
	];
	var transform3 = [
		[[   0,   0],[0.39,0],[0.0,0]],
		[[ 0.5,   0],[0.39,0],[0.1,0]],
		[[0.25,-0.5],[0.39,0],[0.2,0]]
	];
	var transforms = [];
	if(selectedCurve=="1") {
		transforms = sierpinskiTriangleTransforms;
	} else if(selectedCurve=="2") {
		transforms = sierpinskiCarpetTransforms;
	} else if(selectedCurve=="3") {
		transforms = transform3;
	}
	for(var k=0; k<levelOfIteration; k++) {
		var transform = transforms[Math.floor(Math.random()*transforms.length)];
		//console.log(transform);
		z = applyTransformation(z,transform);
		//console.log(z);
		drawPoint(convertPointToScreen(z));
	}
}

paintChaosGame();

function redraw() {
	for(var k=0; k<drawnPoints.length; k++) {
		drawnPoints[k].remove();
	}
	drawnPoints = [];
	paintChaosGame();
}

function selectCurve() {
	selectedCurve = document.getElementById("curveSelect").value;
	redraw();
}

function selectNumber() {
	levelOfIteration = document.getElementById("numberSelect").value;
	calculateSizeOfPoints();
	redraw();
}


</script>
</html>