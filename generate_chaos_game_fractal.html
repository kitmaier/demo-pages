<html>
<body>
<!-- TODO: insert user controls -->
<span style="font-size:50px;">Curve:</span>
<span style="padding-left:5px;padding-right:5px;">
  <select id="curveSelect" name="selectedCurve" onchange="selectCurve()" style="font-size:50px;padding-left:5px;padding-right:5px;">
    <option value="1">1</option>
    <option value="2">2</option>
    <option value="3" selected>3</option>
  </select>
</span>
<span style="font-size:50px;">Detail:</span>
<span style="padding-left:5px;">
  <select id="numberSelect" name="selectedNumber" onchange="selectNumber()" style="font-size:50px;padding-left:5px;padding-right:5px;">
    <option value="10">10</option>
    <option value="100">100</option>
    <option value="1000">1000</option>
    <option value="10000">10000</option>
    <option value="100000" selected>100000</option>
    <option value="1000000">1000000</option>
  </select>
</span>
<p/>
<svg id="svg" height="600" width="800" xmlns="http://www.w3.org/2000/svg">
</svg>
</body>
<script>
var svg = document.getElementById("svg");
var levelOfIteration;
var sizeOfPoints;
var selectedCurve;

// TODO: initialize these values by reading from the html or vice versa
// TODO: global variables like svg width and height, number of points to draw, and selected curve
function calculateSizeOfPoints() {
	sizeOfPoints = 0.2;
	if(levelOfIteration<=100) {
		sizeOfPoints = 10;
	} else if(levelOfIteration<=10000) {
		sizeOfPoints = 1;
	}
}
function initializeGlobalVariables() {
	levelOfIteration = Number(document.getElementById("numberSelect").value);
	selectedCurve = document.getElementById("curveSelect").value;
	calculateSizeOfPoints();
}
initializeGlobalVariables();

/*

Chaos Game fractal generator

TODO: chaos game iterating simple complex-coefficient polynomials eg az+b or az^2+bz+c
TODO: allow user to select from predefined interesting configurations
TODO: allow user to input custom configurations for a fixed number of generators
TODO: allow user to specify a variable-length list of generators
TODO: allow user to specify bounds of viewing box
TODO: ensure even coverage by biasing iteration towards low density areas
	Maybe measure standard deviation of points after each transformation and bias based on that
TODO: maybe take the whole thing as like a dynamic programming problem, just have a two dimensional array of what points have been colored black previously and recently, and at each step all the last stage colored black are moved through all the transformations and any new black cells are the next stage, might not work perfectly if the path from one point to another does not align well with the grid

*/

var drawnPoints = [];

function drawPoint(point) {
	var x = point[0];
	var y = point[1];
	var circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
	circle.setAttribute('cx', x);
	circle.setAttribute('cy', y);
	circle.setAttribute('r', sizeOfPoints);
	circle.setAttribute('fill', "black");
	circle.setAttribute('fill', "black");
	svg.appendChild(circle);
	drawnPoints.push(circle);
}

// functions to apply arithmetic operations to complex numbers
function plus(a,b) {
	return [
		a[0]+b[0],
		a[1]+b[1]
	];
}
function times(a,b) {
	return [
		a[0]*b[0]-a[1]*b[1],
		a[0]*b[1]+a[1]*b[0]
	];
}
function pow(z,n) {
	var zNext = [1,0];
	for(var k=0; k<n; k++) {
		zNext = times(zNext,z);
	}
	return zNext;
}

var varianceData = [];

function storeVarianceData(z,k) {
	varianceData.push([z,k]);
}
function calculateVarianceData() {
	// iterate over the list splitting it up by k-value
	//   could start with just k=3
	// in each k-group
	//   find the X-mean and Y-mean
	//     sum up over all point values and divide by count
	//     running sum of values and running sum of 1 for counts
	//   find the X-variance and Y-variance
	//     for each point find the squared deviation
	//     sum up over all points
	//     divide by one less than number of points
	//   find the overall variance and standard deviation
	var sumX = 0;
	for(var n=0; n<varianceData.length; n++) {
		var data = varianceData[n];
		var x = data[0][0];
		var y = data[0][1];
		var k = data[1];
		
	}
}

// TODO: may need to use roots instead of powers to get something that converges
// TODO: include generic affine transformations such as squeezing in only one direction
// apply polynomial to a complex valued input
function applyTransformation(z,transformation) {
	var zNext = [0,0];
	for(var k=0; k<transformation.length; k++) {
		var c = transformation[k];
		zNext = plus(zNext,times(c,pow(z,k)));
		storeVarianceData(zNext,k);
	}
	return zNext;
}

function convertPointToScreen(z) {
	return [
		300*z[0]+300,
		300*z[1]+400
	];
}

function paintChaosGame() {
	var z = [1,0];
	var sierpinskiTriangleTransforms = [
		[[   0,   0],[0.5,0]],
		[[ 0.5,   0],[0.5,0]],
		[[0.25,-0.5],[0.5,0]]
	];
	var sierpinskiCarpetTransforms = [
		[[       0,        0],[0.333333,0]],
		[[0.333333,        0],[0.333333,0]],
		[[0.666667,        0],[0.333333,0]],
		[[       0,-0.333333],[0.333333,0]],
		[[0.666667,-0.333333],[0.333333,0]],
		[[       0,-0.666667],[0.333333,0]],
		[[0.333333,-0.666667],[0.333333,0]],
		[[0.666667,-0.666667],[0.333333,0]],
	];
	var transform3 = [
		[[   0,   0],[0.39,0],[0.0,0]],
		[[ 0.5,   0],[0.39,0],[0.1,0]],
		[[0.25,-0.5],[0.39,0],[0.2,0]]
	];
	var transforms = [];
	if(selectedCurve=="1") {
		transforms = sierpinskiTriangleTransforms;
	} else if(selectedCurve=="2") {
		transforms = sierpinskiCarpetTransforms;
	} else if(selectedCurve=="3") {
		transforms = transform3;
	}
	for(var k=0; k<levelOfIteration; k++) {
		// TODO: allow user to bias transform selection for artistic effect
		//var transform = transforms[Math.floor(Math.random()*transforms.length)];
		//var transform = transforms[Math.floor(Math.pow(Math.random(),0.6)*transforms.length)];
		var transform = transforms[[0,0,0,0,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2][Math.floor(Math.random()*21)]];
		//console.log(transform);
		z = applyTransformation(z,transform);
		//console.log(z);
		drawPoint(convertPointToScreen(z));
	}
	calculateVarianceData();
}

paintChaosGame();

function redraw() {
	for(var k=0; k<drawnPoints.length; k++) {
		drawnPoints[k].remove();
	}
	drawnPoints = [];
	paintChaosGame();
}

function selectCurve() {
	selectedCurve = document.getElementById("curveSelect").value;
	redraw();
}

function selectNumber() {
	levelOfIteration = document.getElementById("numberSelect").value;
	calculateSizeOfPoints();
	redraw();
}


</script>
</html>