<html>
<body>
<!-- TODO: insert user controls -->
<span style="font-size:50px;">Curve:</span>
<span style="padding-left:5px;padding-right:5px;">
  <select id="curveSelect" name="selectedCurve" onchange="selectCurve()" style="font-size:50px;padding-left:5px;padding-right:5px;">
    <option value="1">1</option>
    <option value="2">2</option>
    <option value="3" selected>3</option>
    <option value="4">4</option>
    <option value="5">5</option>
  </select>
</span>
<span style="font-size:50px;">Detail:</span>
<span style="padding-left:5px;">
  <select id="numberSelect" name="selectedNumber" onchange="selectNumber()" style="font-size:50px;padding-left:5px;padding-right:5px;">
    <option value="10">10</option>
    <option value="100">100</option>
    <option value="1000">1000</option>
    <option value="10000" selected>10000</option>
    <option value="100000">100000</option>
    <option value="1000000">1000000</option>
  </select>
</span>
<p/>
<span style="font-size:50px;" onclick="optimizeTextClicked()">Optimize:</span>
<input type="checkbox" id="OptimizeCheckbox" onchange="optimizeCheckboxClicked()" style="width:50px;height:50px;" checked="true">
<p/>
<table id="configsTable" style="width:800px;"></table>
<p/>
<svg id="svg" height="600" width="800" xmlns="http://www.w3.org/2000/svg">
</svg>
</body>
<script>
let svg = document.getElementById("svg");
let overrideBiasWeights;
let doOptimizeBiasWeights;
let levelOfIteration;
let sizeOfPoints;
let selectedCurve;
let selectedTransforms;
let sierpinskiTriangleTransforms = [
	[[   0,   0],[0.5,0]],
	[[ 0.5,   0],[0.5,0]],
	[[0.25,-0.5],[0.5,0]]
];
let sierpinskiCarpetTransforms = [
	[[       0,        0],[0.333333,0]],
	[[0.333333,        0],[0.333333,0]],
	[[0.666667,        0],[0.333333,0]],
	[[       0,-0.333333],[0.333333,0]],
	[[0.666667,-0.333333],[0.333333,0]],
	[[       0,-0.666667],[0.333333,0]],
	[[0.333333,-0.666667],[0.333333,0]],
	[[0.666667,-0.666667],[0.333333,0]],
];
let transform3 = [
	[[   0,   0],[0.39,0],[0.0,0]],
	[[ 0.5,   0],[0.39,0],[0.1,0]],
	[[0.25,-0.5],[0.39,0],[0.2,0]]
];
let transform4 = [
	[[ 0.5,   0],[0.39,0],[-0.15,0]],
	[[ 0,   0],[0.39,0],[0,0]],
	[[0.5,-0.5],[0.39,0],[0.15,0]]
];
// equilateral triangle scaled down by 1/3 towards all 3 corners,
// and scaled down by 1/sqrt(3) towards center with 30 degree rotation
// TODO: make slightly larger and closer to the middle of the screen
let rezuaqTriangle = [
	[[    0,     0],[0.333,0]],
	[[0.667, 0.385],[0.333,0]],
	[[0.667,-0.385],[0.333,0]],
	[[0.333,0.192],[0.5,-0.289]]
];


// TODO: initialize these values by reading from the html or vice versa
// TODO: global variables like svg width and height, number of points to draw, and selected curve
function calculateSizeOfPoints() {
	sizeOfPoints = 0.2;
	if(levelOfIteration<=100) {
		sizeOfPoints = 10;
	} else if(levelOfIteration<=10000) {
		sizeOfPoints = 1;
	}
}
function selectTransforms() {
	if(selectedCurve=="1") {
		selectedTransforms = structuredClone(sierpinskiTriangleTransforms);
	} else if(selectedCurve=="2") {
		selectedTransforms = structuredClone(sierpinskiCarpetTransforms);
	} else if(selectedCurve=="3") {
		selectedTransforms = structuredClone(transform3);
	} else if(selectedCurve=="4") {
		selectedTransforms = structuredClone(transform4);
	} else if(selectedCurve=="5") {
		selectedTransforms = structuredClone(rezuaqTriangle);
	} else {
		console.log("error - unrecognized transform: "+selectedCurve);
	}
	overrideBiasWeights = [];
}
function initializeGlobalVariables() {
	levelOfIteration = Number(document.getElementById("numberSelect").value);
	selectedCurve = document.getElementById("curveSelect").value;
	doOptimizeBiasWeights = document.getElementById("OptimizeCheckbox").checked;
	calculateSizeOfPoints();
	selectTransforms();
}
initializeGlobalVariables();

/*

Chaos Game fractal generator

TODO: chaos game iterating simple complex-coefficient polynomials eg az+b or az^2+bz+c
TODO: allow user to select from predefined interesting configurations
TODO: allow user to input custom configurations for a fixed number of generators
TODO: allow user to specify a variable-length list of generators
TODO: allow user to specify bounds of viewing box
TODO: ensure even coverage by biasing iteration towards low density areas
	Maybe measure standard deviation of points after each transformation and bias based on that
TODO: maybe take the whole thing as like a dynamic programming problem, just have a two dimensional array of what points have been colored black previously and recently, and at each step all the last stage colored black are moved through all the transformations and any new black cells are the next stage, might not work perfectly if the path from one point to another does not align well with the grid
TODO: study examples from this website and github repo https://rezuaq.be/fractal/

*/

let drawnPoints = [];

function drawPointSize(point,size,color) {
	let x = point[0];
	let y = point[1];
	let circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
	circle.setAttribute('cx', x);
	circle.setAttribute('cy', y);
	circle.setAttribute('r', size);
	circle.setAttribute('fill', color);
	circle.setAttribute('fill', color);
	svg.appendChild(circle);
	drawnPoints.push(circle);
}

function drawPoint(point) {
	drawPointSize(point,sizeOfPoints,'black');
}

// functions to apply arithmetic operations to complex numbers
function plus(a,b) {
	return [
		a[0]+b[0],
		a[1]+b[1]
	];
}
function times(a,b) {
	return [
		a[0]*b[0]-a[1]*b[1],
		a[0]*b[1]+a[1]*b[0]
	];
}
function pow(z,n) {
	let zNext = [1,0];
	for(let k=0; k<n; k++) {
		zNext = times(zNext,z);
	}
	return zNext;
}
function abs(z) {
	return Math.sqrt(z[0]*z[0]+z[1]*z[1]);
}
function distance(z1,z2) {
	let difference = plus(z1,times([-1,0],z2));
	return abs(difference);
}

let varianceData = [];

function storeVarianceData(z,k) {
	varianceData.push([z,k]);
}
function calculateVarianceData() {
	// iterate over the list splitting it up by k-value
	//   could start with just k=3
	// in each k-group
	//   find the X-mean and Y-mean
	//     sum up over all point values and divide by count
	//     running sum of values and running sum of 1 for counts
	//   find the X-variance and Y-variance
	//     for each point find the squared deviation
	//     sum up over all points
	//     divide by one less than number of points
	//   find the overall variance and standard deviation
	let sumX = 0;
	for(let n=0; n<varianceData.length; n++) {
		let data = varianceData[n];
		let x = data[0][0];
		let y = data[0][1];
		let k = data[1];
		
	}
}

// TODO: may need to use roots instead of powers to get something that converges
// TODO: include generic affine transformations such as squeezing in only one direction
// apply polynomial to a complex valued input
function applyTransformation(z,transformation) {
	let zNext = [0,0];
	for(let k=0; k<transformation.length; k++) {
		let c = transformation[k];
		zNext = plus(zNext,times(c,pow(z,k)));
		storeVarianceData(zNext,k);
	}
	return zNext;
}

function convertPointToScreen(z) {
	return [
		300*z[0]+300,
		300*z[1]+400
	];
}

function deleteTableRow(rowId) {
	selectedTransforms.splice(rowId,1);
	overrideBiasWeights.splice(rowId,1);
	redraw();
}

function updateBiasOverride(event,i,biasWeights) {
	overrideBiasWeights = structuredClone(biasWeights);
	// TODO: renormalize biases and prevent out-of-range issues
	overrideBiasWeights[i] = Number(event.target.value)*0.01;
	redraw();
}

function createTable(transforms,biasWeights) {
	// TODO: add column for probability bias
	// TODO: allow user to modify values
	// TODO: allow user to add and delete rows
	// TODO: add column headers or additional columns with static data explaining what each column is for
	configsTable = document.getElementById("configsTable");
	configsTable.style.width = '800px';
	configsTable.style.border = '1px solid black';
	tableBody = configsTable.getElementsByTagName('tbody')[0];
	if(tableBody) {
		tableBody.innerHTML = ''; // Clears all content within the tbody
	}
	for(let i = 0; i < transforms.length; i++) {
		let tr = configsTable.insertRow();
		let td1 = tr.insertCell();
		td1.style.width = '20px';
		td1.style.border = '1px solid black';
		td1.style.fontSize = '20px';
		td1.style.textAlign = 'center';
		let minusButton = document.createElement("button");
		minusButton.innerText = "-";
		minusButton.onclick = function(event){deleteTableRow(i);};
		td1.appendChild(minusButton);
		if(doOptimizeBiasWeights) {
			// TODO: update width of other cells based on whether this one is displayed or not
			let td2 = tr.insertCell();
			td2.style.width = '30px';
			td2.style.border = '1px solid black';
			// TODO: why does this not restrict to 20px?
			td2.style.fontSize = '20px';
			// TODO: figure out how to include a non-editable percentage character here
			let textInput = document.createElement("input");
			textInput.type = 'text';
			textInput.value = Math.round(100*biasWeights[i]);
			textInput.onchange = function(event){updateBiasOverride(event,i,biasWeights);};
			textInput.style.width = '30px';
			td2.appendChild(textInput);
		}
		for(let j = 0; j < transforms[0].length; j++) {
			let td = tr.insertCell();
			td.appendChild(document.createTextNode(transforms[i][j][0]+","+transforms[i][j][1]));
			td.style.width = (750.0/transforms[0].length)+'px';
			td.style.border = '1px solid black';
			td.style.fontSize = '20px';
		}
	}
}

// TODO: optimize this instead of recalculating a lot
function selectRandomBiasedTransform(transforms,biasWeights) {
	let cumulativeWeights = [];
	let sum = 0;
	for(let k=0; k<biasWeights.length; k++) {
		sum += biasWeights[k];
		cumulativeWeights.push(sum);
	}
	let randomValue = Math.random()*sum;
	let index = 0;
	for(let k=0; k<biasWeights.length; k++) {
		if(randomValue<cumulativeWeights[k]) {
			index = k;
			break;
		}
	}
	return transforms[index];
}

function Dsum(volumes,D) {
	let total = 0;
	for(let k=0; k<volumes.length; k++) {
		total += Math.pow(volumes[k],D);
	}
	return total;
}

function calculateDimension(volumes) {
	if(Dsum(volumes,1)<=1) return 1;
	if(Dsum(volumes,2)>=1) return 2;
	var min = 1;
	var max = 2;
	while(min+0.0001<max) {
		var mid = 0.5*(min+max);
		var dimension = Dsum(volumes,mid);
		if(dimension>1) {
			min = mid;
		} else if(dimension<1) {
			max = mid;
		} else {
			min = mid;
			max = mid;
		}
	}
	return 0.5*(min+max);
}

function calculateVolumeRatios1(transforms,fixedPoints) {
	let volume = [];
	for(let k=0; k<transforms.length; k++) {
		volume.push(1.0);
		let f0 = fixedPoints[k];
		let transform = transforms[k];
		for(let j=0; j<transforms.length; j++) {
			// TODO: handle case where there's only one transform?
			if(j==k) continue;
			let f1 = fixedPoints[j];
			f2 = applyTransformation(f1,transform);
			let dist1 = distance(f0,f1);
			let dist2 = distance(f0,f2);
			volume[k] = volume[k]*(dist2/dist1);
			// TODO: allow user to decide to draw these
			// drawPointSize(convertPointToScreen(f2),10,'red');
		}
		// Geometric mean of distance ratios for summary data
		volume[k] = Math.pow(volume[k],1.0/(transforms.length-1));
	}
	return volume
}

function calculateVolumeRatios2(transforms,fixedPoints) {
	let volume = [];
	for(let k=0; k<transforms.length; k++) {
		volume.push(1.0);
		let transform = transforms[k];
		for(let j=0; j<transforms.length; j++) {
			// TODO: handle case where there's only one transform?
			if(j==k) continue;
			let distances = [];
			let f1 = fixedPoints[j];
			// TODO: try out different number of iterations or try continuing until point stops moving
			for(let m=0; m<20; m++) {
				f2 = applyTransformation(f1,transform);
				distances.push(distance(f1,f2));
				f1 = f2;
				// TODO: allow user to decide to draw these
				// drawPointSize(convertPointToScreen(f2),5,'red');
			}
			// TODO: what if the ratio is zero?
			let distanceRatioBundle = 1.0;
			for(let m=1; m<distances.length; m++) {
				distanceRatioBundle = distanceRatioBundle*distances[m]/distances[m-1];
			}
			volume[k] = volume[k]*Math.pow(distanceRatioBundle,1.0/(distances.length-1));
		}
		// Geometric mean of distance ratios for summary data
		volume[k] = Math.pow(volume[k],1.0/(transforms.length-1));
	}
	return volume
}

function calculateVolumeRatios3(transforms,fixedPoints) {
	let volume = calculateVolumeRatios2(transforms,fixedPoints);
	if(transforms.length<=2) return volume;
	for(let k=0; k<transforms.length; k++) {
		let newVolume = 1.0;
		let transform = transforms[k];
		for(let j=0; j<transforms.length; j++) {
			// TODO: handle case where there's only one transform?
			if(j==k) continue;
			let nextJ = j+(j+1==k?2:1);
			if(nextJ>=transforms.length) {
				nextJ -= transforms.length;
				if(nextJ==k) nextJ++;
			}
			let f1 = fixedPoints[j];
			let f2 = fixedPoints[nextJ];
			let dist1 = distance(f1,f2);
			let f3 = applyTransformation(f1,transform);
			let f4 = applyTransformation(f2,transform);
			let dist2 = distance(f3,f4);
			// TODO: what if the ratio is zero?
			newVolume *= dist2/dist1;
		}
		// Geometric mean of distance ratios for summary data
		//volume[k] *= Math.pow(newVolume,1.0/(transforms.length-1));
		//volume[k] = Math.pow(volume[k],0.5);
		volume[k] = Math.pow(newVolume,1.0/(transforms.length-1));
	}
	return volume
}

function optimizeBiasWeights(transforms,z) {
	let fixedPoints = [];
	for(let k=0; k<transforms.length; k++) {
		let z2 = structuredClone(z);
		let transform = transforms[k];
		// TODO: try running this until the point stops moving
		for(let m=0; m<10; m++) {
			z2 = applyTransformation(z2,transform);
		}
		// TODO: what if a transform has more than one fixed point?
		fixedPoints.push(z2);
		// TODO: allow user to decide to draw these
		// drawPointSize(convertPointToScreen(z2),10,'red');
	}
	//let volume = calculateVolumeRatios1(transforms,fixedPoints);
	//let volume = calculateVolumeRatios2(transforms,fixedPoints);
	let volume = calculateVolumeRatios3(transforms,fixedPoints);
	let D = calculateDimension(volume);
	let weights = []
	for(let k=0; k<transforms.length; k++) {
		weights.push(Math.pow(volume[k],D));
	}
	// TODO: add a small amount to each value and renormalize to handle case where something is set too close to zero
	return weights;
}

function paintChaosGame() {
	let z = [1,0];
	let transforms = selectedTransforms;
	let biasWeights = [];
	for(let k=0; k<transforms.length; k++) {
		biasWeights.push(1.0/transforms.length);
	}
	//optimizeBiasWeights(transforms,z);
	if(doOptimizeBiasWeights) {
		biasWeights = optimizeBiasWeights(transforms,z);
	}
	if(doOptimizeBiasWeights&&overrideBiasWeights.length>0) {
		biasWeights = structuredClone(overrideBiasWeights);
	}
	createTable(transforms,biasWeights);
	let trashIterations = Math.sqrt(levelOfIteration);
	for(let k=0; k<trashIterations; k++) {
		// run through a small number of iterations in order to converge to fractal and not display a bunch of noisy dots
		let transform = transforms[Math.floor(Math.random()*transforms.length)];
		z = applyTransformation(z,transform);
	}
	for(let k=0; k<levelOfIteration; k++) {
		// TODO: allow user to bias transform selection for artistic effect
		let transform = selectRandomBiasedTransform(transforms,biasWeights);
		z = applyTransformation(z,transform);
		drawPoint(convertPointToScreen(z));
	}
	calculateVarianceData();
}

paintChaosGame();

function redraw() {
	for(let k=0; k<drawnPoints.length; k++) {
		drawnPoints[k].remove();
	}
	drawnPoints = [];
	paintChaosGame();
}

function selectCurve() {
	selectedCurve = document.getElementById("curveSelect").value;
	selectTransforms();
	redraw();
}

function selectNumber() {
	levelOfIteration = document.getElementById("numberSelect").value;
	calculateSizeOfPoints();
	redraw();
}

function optimizeCheckboxClicked() {
	doOptimizeBiasWeights = document.getElementById("OptimizeCheckbox").checked;
	redraw();
}

function optimizeTextClicked() {
	let checked = document.getElementById("OptimizeCheckbox").checked;
	document.getElementById("OptimizeCheckbox").checked = !checked;
	filledCheckboxClicked();
}


</script>
</html>