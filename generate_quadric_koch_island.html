<html>
<body>
<span style="font-size:50px;">Curve:</span>
<span style="padding-left:5px;padding-right:5px;">
<select id="curveSelect" name="selectedCurve" onchange="selectCurve()" style="font-size:50px;padding-left:5px;padding-right:5px;">
  <option value="L8/L4" selected>L8/L4</option>
  <option value="L18/L6">L18/L6</option>
  <option value="L32/L8">L32/L8</option>
  <option value="L98/L14">L98/L14</option>
</select>
</span>
<span style="font-size:50px;">Detail:</span>
<span style="padding-left:5px;padding-right:5px;">
<select id="numberSelect" name="selectedNumber" onchange="selectNumber()" style="font-size:50px;padding-left:5px;padding-right:5px;">
  <option value="1" selected>1</option>
  <option value="2">2</option>
  <option value="3">3</option>
  <option value="4">4</option>
</select>
</span>
<span style="font-size:50px;" onclick="filledTextClicked()">Filled:</span>
<input type="checkbox" id="FilledCheckbox" onchange="filledCheckboxClicked()" style="width:50px;height:50px;" checked="true">
<p/>
<svg id="svg" height="600" width="800" xmlns="http://www.w3.org/2000/svg">
</svg>
</body>
<script>
var svg = document.getElementById("svg");

// TODO: initialize these values by reading from the html or vice versa
var levelOfIteration = 1;
var isFilled = true;
var selectedCurve = "L8/L4";
var svgWidth = 800;
var svgHeight = 600;

/*

Quadric Koch Island (The Fractal Geometry of Nature page 50-54)
TODO: randomize whether the spike points inwards or outwards
TODO: randomize or vary the angles
TODO: include 0-detail option with just straight lines
TODO: create a table to align the options and labels

*/

var unitPoints = [];

var unitPointsL8L4 = 
 [[0,0],
  [1,0],
  [1,1],
  [2,1],
  [2,0],
  [2,-1],
  [3,-1],
  [3,0],
  [4,0]];
function normalizeUnitPointsL8L4() {
	for(var k=0; k<unitPointsL8L4.length; k++) {
		var point = unitPointsL8L4[k];
		point[0] = point[0]/4.0;
		point[1] = point[1]/4.0;
	}
}
normalizeUnitPointsL8L4();

var unitPointsL18L6 = 
 [[0,0],
  [1,0],
  [1,1],
  [1,2],
  [2,2],
  [3,2],
  [3,1],
  [2,1],
  [2,0],
  [3,0],
  [4,0],
  [4,-1],
  [3,-1],
  [3,-2],
  [4,-2],
  [5,-2],
  [5,-1],
  [5,0],
  [6,0]];
function normalizeUnitPointsL18L6() {
	for(var k=0; k<unitPointsL18L6.length; k++) {
		var point = unitPointsL18L6[k];
		point[0] = point[0]/6.0;
		point[1] = point[1]/6.0;
	}
}
normalizeUnitPointsL18L6();

var unitPointsL32L8 = 
 [[0,0],
  [0,1],
  [1,1],
  [1,2],
  [0,2],
  [0,3],
  [1,3],
  [2,3],
  [2,4],
  [3,4],
  [3,3],
  [3,2],
  [2,2],
  [2,1],
  [3,1],
  [4,1],
  [4,0],
  [4,-1],
  [5,-1],
  [6,-1],
  [6,-2],
  [5,-2],
  [5,-3],
  [5,-4],
  [6,-4],
  [6,-3],
  [7,-3],
  [8,-3],
  [8,-2],
  [7,-2],
  [7,-1],
  [8,-1],
  [8,0]];
function normalizeUnitPointsL32L8() {
	for(var k=0; k<unitPointsL32L8.length; k++) {
		var point = unitPointsL32L8[k];
		point[0] = point[0]/8.0;
		point[1] = point[1]/8.0;
	}
}
normalizeUnitPointsL32L8();

var unitPointsL98L14Generator = [
 [  0,  0,  0,  0,  0,  0, 22, 23,  0,  0,  0,  0,  0,  0,  0],
 [  0,  0,  0,  0,  0,  0, 21, 24, 25, 26,  0,  0,  0,  0,  0],
 [  0,  0,  0,  0,  0, 19, 20, 33, 32, 27, 28,  0,  0,  0,  0],
 [  0,  0,  0, 16, 17, 18, 35, 34, 31, 30, 29,  0,  0,  0,  0],
 [  0,  0,  0, 15, 14, 13, 36, 37, 38, 39, 40, 91, 92,  0,  0],
 [  0,  2,  3, 10, 11, 12, 47, 46, 45, 44, 41, 90, 93,  0,  0],
 [  0,  1,  4,  9, 56, 55, 48, 49, 50, 43, 42, 89, 94, 97, 98],
 [  0,  0,  5,  8, 57, 54, 53, 52, 51, 86, 87, 88, 95, 96,  0],
 [  0,  0,  6,  7, 58, 59, 60, 61, 62, 85, 84, 83,  0,  0,  0],
 [  0,  0,  0,  0, 69, 68, 67, 64, 63, 80, 81, 82,  0,  0,  0],
 [  0,  0,  0,  0, 70, 71, 66, 65, 78, 79,  0,  0,  0,  0,  0],
 [  0,  0,  0,  0,  0, 72, 73, 74, 77,  0,  0,  0,  0,  0,  0],
 [  0,  0,  0,  0,  0,  0,  0, 75, 76,  0,  0,  0,  0,  0,  0]];
var unitPointsL98L14 = [];
function generateUnitPointsL98L14() {
	for(var k=0; k<99; k++) {
		unitPointsL98L14.push([0,0]);
	}
	for(var r=0; r<=12; r++) {
		for(var c=0; c<=14; c++) {
			var generatorValue = unitPointsL98L14Generator[r][c];
			if(generatorValue==0) continue;
			var x = c/14.0;
			var y = (6-r)/14.0;
			unitPointsL98L14[generatorValue][0] = x;
			unitPointsL98L14[generatorValue][1] = y;
		}
	}
}
generateUnitPointsL98L14();

function setUnitPoints() {
	unitPoints = [];
	var unitPointsSource = [];
	if(selectedCurve=="L8/L4") {
		unitPointsSource = unitPointsL8L4;
	} else if(selectedCurve=="L18/L6") {
		unitPointsSource = unitPointsL18L6;
	} else if(selectedCurve=="L32/L8") {
		unitPointsSource = unitPointsL32L8;
	} else if(selectedCurve=="L98/L14") {
		unitPointsSource = unitPointsL98L14;
	} else {
		console.log("ERROR - curve name not recognized: "+selectedCurve);
	}
	for(var k=0; k<unitPointsSource.length; k++) {
		unitPoints.push(unitPointsSource[k]);
	}
}
setUnitPoints();

var polygons = [];

function appendPoint(x,y,polygon) {
	var point = svg.createSVGPoint();
	point.x = x;
	point.y = y;
	polygon.points.appendItem(point);
}

function paintKochCurve(x1,y1,x2,y2,level,polygon) {
	// (a+bi)(c+di) = (ac-bd)+(ad+bc)i
	var c = x2-x1;
	var d = y2-y1;
	if(c*c+d*d<1) {
		appendPoint(x2,y2,polygon);
		return;
	}
	var transformedPoints = [];
	for(var k=0; k<unitPoints.length; k++) {
		var a = unitPoints[k][0];
		var b = unitPoints[k][1];
		var transformedPoint = [0,0];
		transformedPoints.push(transformedPoint);
		transformedPoint[0] = a*c-b*d+x1;
		transformedPoint[1] = a*d+b*c+y1;
	}
	for(var k=0; k<transformedPoints.length-1; k++) {
		var p1 = transformedPoints[k];
		var p2 = transformedPoints[k+1];
		if(level==0) {
			appendPoint(p2[0],p2[1],polygon);
		} else {
			paintKochCurve(p1[0],p1[1],p2[0],p2[1],level-1,polygon);
		}
	}
}

/*
corners of the large square:
x,y
x+a+b,y
x+a+b,y+a+b
x,y+a+b

corners of the small square:
x+b,y
x+a+b,y+b
x+a,y+a+b
x,y+a

.....X----..........
....|.....----......
...|..........----..
..|...............-X
..|................|
.|................|.
|................|..
X...............|...
.----..........|....
.....----.....|.....
.........----X......
*/
function paintKochPolygon(x,y,a,b,level) {
	var polygon = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
	if(isFilled) {
		polygon.setAttribute("style", "fill:black;stroke:black;stroke-width:0");
	} else {
		polygon.setAttribute("style", "fill:none;stroke:black;stroke-width:1");
	}
	svg.appendChild(polygon);
	polygons.push(polygon);
	paintKochCurve(x+b,y,x+a+b,y+b,level,polygon);
	paintKochCurve(x+a+b,y+b,x+a,y+a+b,level,polygon);
	paintKochCurve(x+a,y+a+b,x,y+a,level,polygon);
	paintKochCurve(x,y+a,x+b,y,level,polygon);
}

// TODO: allow the user to control size of tiling
function paintKochPolygonTiles(level) {
	var x=svgWidth/2;
	var y=svgHeight/2;
	var a=100;
	var b=50;
	for(var r=-10; r<=10; r++) {
		for(var c=-10; c<=10; c++) {
			if(Math.abs(r+c)%2==0) {
				var x2 = x+r*a-c*b;
				var y2 = y+r*b+c*a;
				if(x2>svgWidth||y2>svgHeight||x2+a+b<0||y2+a+b<0) continue;
				paintKochPolygon(x2,y2,a,b,level);
			}
		}
	}
}

paintKochPolygonTiles(levelOfIteration-1);

function redraw() {
	for(var k=0; k<polygons.length; k++) {
		polygons[k].remove();
	}
	polygons = [];
	paintKochPolygonTiles(levelOfIteration-1);
}

function selectNumber() {
	levelOfIteration = document.getElementById("numberSelect").value;
	redraw();
}

function filledCheckboxClicked() {
	isFilled = document.getElementById("FilledCheckbox").checked;
	for(var k=0; k<polygons.length; k++) {
		var polygon = polygons[k];
		if(isFilled) {
			polygon.style.fill = "black";
			polygon.style.strokeWidth = 0;
		} else {
			polygon.style.fill = "none";
			polygon.style.strokeWidth = 1;
		}
	}
}

function filledTextClicked() {
	var checked = document.getElementById("FilledCheckbox").checked;
	document.getElementById("FilledCheckbox").checked = !checked;
	filledCheckboxClicked();
}

function selectCurve() {
	selectedCurve = document.getElementById("curveSelect").value;
	setUnitPoints();
	redraw();
}

</script>
</html>